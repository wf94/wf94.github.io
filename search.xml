<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Climbing Stairs：分治法初探]]></title>
      <url>http://wf94.github.io/2017/03/09/Climbing-Stairs-Divide-and-Conquer/</url>
      <content type="html"><![CDATA[<p>在算法书里，我们总能看得到一道经典的题目。</p>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 </p>
</blockquote>
<p>我们可以利用分治法来解决这一题。首先需要找到上台阶子问题的分割方法，再递归地求解子问题，最后把所有子问题的结果合并。</p>
<p>很容易看出，只有1级台阶的时候，只有1种跳法。2级台阶有2种跳法，3级台阶有3种跳法。如果有4级台阶，有5种跳法。</p>
<p>怎么求呢？我们可以把求解4级台阶，分解成求解两个2级台阶的子问题。这样一来，我们可以算出2×2种不同的跳法【1-2-3-4，12-3-4，1-2-34，12-34】。需要注意的是，分解成两个子问题之后，还会有跨越这两个子问题的情况。在本题中，跨越子问题的情况只可能是从前一个子问题，到下一个子问题，走过了两级台阶。在4级台阶中，这种情况是【1-23-4】</p>
<p>所以我们在合并所有子问题的时候，将上述两种情况合并起来就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="keyword">return</span> self.helper(number)</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, number)</span>:</span></div><div class="line">        <span class="keyword">if</span> (number &lt;= <span class="number">3</span>):</div><div class="line">            <span class="keyword">return</span> number</div><div class="line">       	<span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>):</div><div class="line">                <span class="comment"># 台阶个数为偶数，恰好能等分成两个子问题</span></div><div class="line">                <span class="comment"># 子问题内的跳法个数 + 跨越子问题的跳法个数</span></div><div class="line">            	<span class="keyword">return</span> self.helper(number / <span class="number">2</span>) * self.helper(number / <span class="number">2</span>) + self.helper(number / <span class="number">2</span> - <span class="number">1</span>) * self.helper(number / <span class="number">2</span> <span class="number">-1</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="comment"># 台阶个数为奇数，分割子问题的时候尽量均分</span></div><div class="line">                <span class="comment"># 子问题内的跳法个数 + 跨越子问题的跳法个数</span></div><div class="line">                <span class="keyword">return</span> self.helper(number / <span class="number">2</span>) * self.helper(number - number / <span class="number">2</span>) + self.helper(number / <span class="number">2</span> - <span class="number">1</span>) * self.helper(number - number / <span class="number">2</span> <span class="number">-1</span>)</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Divide and Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[241 Different Ways to Add Parentheses：分治法初探]]></title>
      <url>http://wf94.github.io/2017/03/09/241-Different-Ways-to-Add-Parentheses/</url>
      <content type="html"><![CDATA[<p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are <code>+</code>, <code>-</code> and <code>*</code>.</p>
<p>Example 1</p>
<p>Input: <code>&quot;2-1-1&quot;</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">((2-1)-1) = 0</div><div class="line">(2-(1-1)) = 2</div></pre></td></tr></table></figure>
<p>Output: <code>[0, 2]</code></p>
<p>Example 2</p>
<p>Input: <code>&quot;2*3-4*5&quot;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(2*(3-(4*5))) = -34</div><div class="line">((2*3)-(4*5)) = -14</div><div class="line">((2*(3-4))*5) = -10</div><div class="line">(2*((3-4)*5)) = -10</div><div class="line">(((2*3)-4)*5) = 10</div></pre></td></tr></table></figure>
<p>Output: <code>[-34, -14, -10, -10, 10]</code></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题如果先把所有的情况的算式用字符串的方式存储起来，再分别用中缀表达式转后缀表达式，会显得非常复杂。这也不是题意所要求的。</p>
<p>我们需要采用分治法来解决此问题。</p>
<blockquote>
<p>分治法适用于什么样的情况呢？分治法所能解决的问题一般具有以下几个特征：    </p>
<ol>
<li><p>该问题的规模缩小到一定的程度就可以容易地解决    </p>
</li>
<li><p>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。    </p>
</li>
<li><p>利用该问题分解出的子问题的解可以合并为该问题的解；    </p>
</li>
<li><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p>
</li>
</ol>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p><strong>第二条特征是应用分治法的前提</strong>，它也是大多数问题可以满足的，此特征反映了递归思想的应用；</p>
<p><strong>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征</strong>，如果<strong>具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法</strong>。</p>
<p><strong>第四条特征涉及到分治法的效率</strong>，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但<strong>一般用动态规划法较好</strong>。</p>
</blockquote>
<p>满足了以上条件，我们来遵循分治法的步骤分析这个问题。</p>
<p>首先，我们需要将原问题分解成为规模比较小的子问题；之后，我们需要递归地将子问题进行求解；最后，我们把子问题的解合并为原问题的解。这也就是分治法的三个步骤。</p>
<p>具体而言， <code>&quot;2*3-4*5&quot;</code>可以分解为以下三个子问题：2 / 345; 23 / 45; 234 / 5。我们在划分的时候，数字长度如果为n，我们就需要划分n-1次。每一次划分之间的结果相互独立，也满足了前文所述的分治法第四条特征。</p>
<p>解决子问题，就需要采取递归的方式。最后，将所求的答案输出到数组里即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span><span class="params">(self, input)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type input: str</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        s = [<span class="string">"+"</span>,<span class="string">"-"</span>,<span class="string">"*"</span>]</div><div class="line">        digits = []</div><div class="line">        symbols = []</div><div class="line">        self.ans = []</div><div class="line">        tmp = <span class="string">''</span></div><div class="line">        <span class="comment"># 注意算式中数字和符号的划分</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> input:</div><div class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> s:</div><div class="line">                symbols.append(i)</div><div class="line">                digits.append(int(tmp))</div><div class="line">                tmp = <span class="string">''</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                tmp += i</div><div class="line">        digits.append(int(tmp))</div><div class="line">                </div><div class="line">        self.length = len(digits)</div><div class="line">        <span class="keyword">return</span> self.subproblem(digits, symbols)</div><div class="line"></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subproblem</span><span class="params">(self, digits, symbols)</span>:</span></div><div class="line">        n = len(digits)</div><div class="line">        <span class="comment"># 最后求得的结果用数组保存。</span></div><div class="line">        <span class="comment"># 因为当 n == 3 时，已经出现两个结果，返回值需放在数组当中</span></div><div class="line">        result = []</div><div class="line">        <span class="comment"># 解决最简单的子问题 n == 1</span></div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>):</div><div class="line">            <span class="keyword">return</span> [digits[<span class="number">0</span>]]</div><div class="line">        <span class="comment"># 在这个地方，有三个if语句的判断，可以将其放在一个helper函数里，会比较简洁。</span></div><div class="line">        <span class="comment"># n == 2 时的结果</span></div><div class="line">        <span class="keyword">elif</span> (n == <span class="number">2</span>):</div><div class="line">            <span class="keyword">if</span> (symbols[<span class="number">0</span>] == <span class="string">'+'</span>):</div><div class="line">                result = [digits[<span class="number">0</span>] + digits[<span class="number">1</span>]]</div><div class="line">            <span class="keyword">elif</span> (symbols[<span class="number">0</span>] == <span class="string">'-'</span>):</div><div class="line">                result = [digits[<span class="number">0</span>] - digits[<span class="number">1</span>]]</div><div class="line">            <span class="keyword">elif</span> (symbols[<span class="number">0</span>] == <span class="string">'*'</span>):</div><div class="line">                result = [digits[<span class="number">0</span>] * digits[<span class="number">1</span>]]</div><div class="line">            <span class="keyword">return</span> result</div><div class="line">        <span class="comment"># n &gt; 2</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, n):</div><div class="line">                <span class="keyword">if</span> (symbols[k<span class="number">-1</span>] == <span class="string">"+"</span>):</div><div class="line">                    <span class="comment"># 由于函数返回值是一个数组，我们将结果全部遍历</span></div><div class="line">                    <span class="comment"># 进行操作之后，得到新的一组结果</span></div><div class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> self.subproblem(digits[:k], symbols[:k<span class="number">-1</span>]):</div><div class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> self.subproblem(digits[k:], symbols[k:]):</div><div class="line">                            result.append(i + j)</div><div class="line">                <span class="keyword">elif</span> (symbols[k<span class="number">-1</span>] == <span class="string">"-"</span>):</div><div class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> self.subproblem(digits[:k], symbols[:k<span class="number">-1</span>]):</div><div class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> self.subproblem(digits[k:], symbols[k:]):</div><div class="line">                            result.append(i - j)</div><div class="line">                <span class="keyword">elif</span> (symbols[k<span class="number">-1</span>] == <span class="string">"*"</span>):</div><div class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> self.subproblem(digits[:k], symbols[:k<span class="number">-1</span>]):</div><div class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> self.subproblem(digits[k:], symbols[k:]):</div><div class="line">                            result.append(i * j)</div><div class="line">                    </div><div class="line">            <span class="keyword">return</span> result</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Divide and Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[216 Combination Sum III]]></title>
      <url>http://wf94.github.io/2017/03/06/216-Combination-Sum-III/</url>
      <content type="html"><![CDATA[<p>Find all possible combinations of <strong>k</strong> numbers that add up to a number <strong>n</strong>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p><strong>Example 1:</strong></p>
<p>Input:  <strong>k</strong> = 3,  <strong>n</strong> = 7</p>
<p>Output: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[1,2,4]]</div></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<p>Input:  <strong>k</strong> = 3,  <strong>n</strong> = 9</p>
<p>Output: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[1,2,6], [1,3,5], [2,3,4]]</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目需要我们找到利用k个不重复数字相加，得到数字n的所有组合。</p>
<p>首先想到暴力搜索，思考一下，k取1-9之间，最多会有多少种情况？答案是k取4时，C(9, 4) = 126种。k取其它数值，情况数只会比126要少。</p>
<p>现在的关键问题就是给定k，我们需要知道从1-9中取k个数的所有组合，再根据题意筛选所需的组合即可。</p>
<p>此时我们还是可以利用回溯的方法，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> copy</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type k: int</div><div class="line">        :type n: int</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        self.digits = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">        self.combs = []</div><div class="line">        self.len = <span class="number">9</span></div><div class="line">        result = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</div><div class="line">            result.append(<span class="number">0</span>)</div><div class="line">        self.comb(k, n, <span class="number">0</span>, <span class="number">0</span>, result)</div><div class="line">        <span class="keyword">return</span> self.combs</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">comb</span><span class="params">(self, k, n, curnum, curlen, result)</span>:</span></div><div class="line">        <span class="keyword">if</span> (curlen &gt;= k):</div><div class="line">            ans = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> result:</div><div class="line">                ans += i</div><div class="line">            <span class="keyword">if</span> (ans == n):</div><div class="line">                tmp = copy.copy(result)</div><div class="line">                self.combs.append(tmp)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> self.digits[curnum:]:</div><div class="line">                result[curlen] = i</div><div class="line">                self.comb(k, n, i, curlen + <span class="number">1</span>, result)</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>Python- itertools中组合数的实现：<br><a href="https://docs.python.org/2/library/itertools.html" target="_blank" rel="external">https://docs.python.org/2/library/itertools.html</a><br>组合问题的求解：<br><a href="http://wuchong.me/blog/2014/07/28/permutation-and-combination-realize/" target="_blank" rel="external">http://wuchong.me/blog/2014/07/28/permutation-and-combination-realize/</a><br>组合问题的求解：<br><a href="http://blog.csdn.net/zmazon/article/details/8315418" target="_blank" rel="external">http://blog.csdn.net/zmazon/article/details/8315418</a><br>LeetCode 77题 - Combination 解法大全：<br><a href="http://www.cnblogs.com/TenosDoIt/p/3461555.html" target="_blank" rel="external">http://www.cnblogs.com/TenosDoIt/p/3461555.html</a><br>排列组合算法：<br><a href="http://www.cnblogs.com/TenosDoIt/p/3695472.html" target="_blank" rel="external">http://www.cnblogs.com/TenosDoIt/p/3695472.html</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Medium </tag>
            
            <tag> Backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[022 Generate Parentheses]]></title>
      <url>http://wf94.github.io/2017/03/06/022-Generate-Parentheses/</url>
      <content type="html"><![CDATA[<p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses. </p>
<p>For example, given <em>n</em> = 3, a solution set is: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &quot;((()))&quot;,</div><div class="line">  &quot;(()())&quot;,</div><div class="line">  &quot;(())()&quot;,</div><div class="line">  &quot;()(())&quot;,</div><div class="line">  &quot;()()()&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求取组合数，或是要求取给定条件的所有情况，可以利用回溯+递归的方法来解决。</p>
<p>在往下寻找每一种情况并回溯的时候，会由于条件所限，去除许多不必要的分支。所以算法实际的复杂度会比纯暴力搜索的方法降低许多。</p>
<ul>
<li>解释一下递归函数<code>trial(self, cur, tmp, tmpsum, trues, falses, n)</code>当中各个变量的含义：</li>
</ul>
<p><code>cur</code>: 当前需要加入临时数组的变量【 “(“ 或 “)” 】【True 或 False】</p>
<p><code>tmp</code>: 一个临时数组，存储递归到当前深度True/False的所有值。</p>
<p><code>tmpsum</code>: 递归当前深度数组的和 (True + True = 2， False + False = 0)【其实可以把这个变量删去，只用统计Trues和falses的值就好】</p>
<p><code>trues</code> / <code>falses</code>: 左括号和右括号的个数</p>
<ul>
<li>关键判断语句：</li>
</ul>
<p><code>if (tmpsum * 2 &lt; trues + falses):</code></p>
<p>或是</p>
<p><code>if (trues &lt; falses)</code></p>
<p>如果访问到当前元素，左括号的数目比右括号要少，即可判定为非法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> copy</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: List[str]</div><div class="line">        """</div><div class="line">        <span class="comment"># True for '('</span></div><div class="line">        <span class="comment"># False for ')'</span></div><div class="line">        self.res = []</div><div class="line">        tmpsum = <span class="number">0</span></div><div class="line">        self.trial(<span class="keyword">True</span>, [], tmpsum, <span class="number">1</span>, <span class="number">0</span>, n)</div><div class="line">        <span class="keyword">return</span> self.res</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trial</span><span class="params">(self, cur, tmp, tmpsum, trues, falses, n)</span>:</span></div><div class="line">        tmp.append(cur)</div><div class="line">        tmpsum += cur</div><div class="line">        <span class="keyword">if</span> (tmpsum * <span class="number">2</span> &lt; trues + falses):</div><div class="line">            tmp = []</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">elif</span> (trues == n <span class="keyword">and</span> falses == n):</div><div class="line">            ans = []</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> tmp:</div><div class="line">                <span class="keyword">if</span> (i):</div><div class="line">                    ans.append(<span class="string">"("</span>)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    ans.append(<span class="string">")"</span>)</div><div class="line">            self.res.append(<span class="string">""</span>.join(ans))</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> (trues &lt; n):</div><div class="line">                cpy = copy.copy(tmp)</div><div class="line">                self.trial(<span class="keyword">True</span>, cpy, tmpsum, trues+<span class="number">1</span>, falses, n)</div><div class="line">            <span class="keyword">if</span> (falses &lt; n):</div><div class="line">                cpy = copy.copy(tmp)</div><div class="line">                self.trial(<span class="keyword">False</span>, cpy, tmpsum, trues, falses+<span class="number">1</span>, n)</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
            <tag> Backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[012 Integer to Roman]]></title>
      <url>http://wf94.github.io/2017/03/06/012-Integer-to-Roman/</url>
      <content type="html"><![CDATA[<p>Given an integer, convert it to a roman numeral. </p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这一题需要我们把一个1-3999的整数，转换成罗马数字。</p>
<p>注意罗马数字的组成规则即可。1000是M，900是CM，500是D，400是CD。跨位不受影响。</p>
<p>举例：</p>
<p>1999是 MCMXCIX –&gt; M/CM/XC/IX/</p>
<p>1876是 MDCCCLXXVI –&gt; M/DCCC/LXX/VI/</p>
<p>罗马数字简直反人类，活该外国小朋友学不好数学哈哈哈哈哈</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type num: int</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        basics = [<span class="string">"I"</span>,<span class="string">"II"</span>,<span class="string">"III"</span>,<span class="string">"IV"</span>,<span class="string">"V"</span>,<span class="string">"VI"</span>,<span class="string">"VII"</span>,<span class="string">"VIII"</span>,<span class="string">"IX"</span>]</div><div class="line">        res = <span class="string">""</span></div><div class="line">        m = num / <span class="number">1000</span></div><div class="line">        <span class="keyword">if</span> (m &gt; <span class="number">0</span>):</div><div class="line">            num = num - <span class="number">1000</span> * m</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</div><div class="line">                res += <span class="string">"M"</span></div><div class="line">            </div><div class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">900</span>):</div><div class="line">            res += <span class="string">"CM"</span></div><div class="line">            num = num - <span class="number">900</span></div><div class="line">        <span class="keyword">elif</span> (num &lt; <span class="number">900</span> <span class="keyword">and</span> num &gt;= <span class="number">500</span>):</div><div class="line">            res += <span class="string">"D"</span></div><div class="line">            num = num - <span class="number">500</span></div><div class="line">        <span class="keyword">elif</span> (num &gt;= <span class="number">400</span> <span class="keyword">and</span> num &lt; <span class="number">500</span>):</div><div class="line">            res += <span class="string">"CD"</span></div><div class="line">            num = num - <span class="number">400</span></div><div class="line">        </div><div class="line">        c = num / <span class="number">100</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ( c &gt; <span class="number">0</span> ):</div><div class="line">            num = num - <span class="number">100</span> * c</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(c):</div><div class="line">                res += <span class="string">"C"</span></div><div class="line">                </div><div class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">90</span>):</div><div class="line">            res += <span class="string">"XC"</span></div><div class="line">            num = num - <span class="number">90</span></div><div class="line">        <span class="keyword">elif</span> (num &lt; <span class="number">90</span> <span class="keyword">and</span> num &gt;= <span class="number">50</span>):</div><div class="line">            res += <span class="string">"L"</span></div><div class="line">            num = num - <span class="number">50</span></div><div class="line">        <span class="keyword">elif</span> (num &gt;= <span class="number">40</span> <span class="keyword">and</span> num &lt; <span class="number">50</span>):</div><div class="line">            res += <span class="string">"XL"</span></div><div class="line">            num = num - <span class="number">40</span></div><div class="line">        </div><div class="line">        x = num / <span class="number">10</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ( x &gt; <span class="number">0</span> ):</div><div class="line">            num = num - <span class="number">10</span> * x</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</div><div class="line">                res += <span class="string">"X"</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>):</div><div class="line">            res += basics[num<span class="number">-1</span>]</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用Docker配置基础Caffe环境]]></title>
      <url>http://wf94.github.io/2017/02/28/Playing-with-Docker-Caffe/</url>
      <content type="html"><![CDATA[<p><del>闲来无事【划掉！！！】</del>，我听闻Caffe在配置起来超级麻烦，又是编译有问题，又是依赖解决不了，十分棘手。我马上联想起了方便轻量的Docker。为何不利用Docker在自己的笔记本电脑上搭建Caffe来玩玩呢？</p>
<a id="more"></a>
<ul>
<li><p><strong>第一步，配置Docker For Windows</strong></p>
<p>首先我们需要配置好属于自己的轻量级虚拟化环境！</p>
<p>在Docker官网上下载属于自己系统的版本，<a href="https://www.docker.com/products/overview" target="_blank" rel="external">https://www.docker.com/products/overview</a></p>
<p>我的系统是Windows 10 Professional，Docker For Windows正好适合我。如果是Windows 10之前的版本，需要下载Docker Toolbox来安装Docker环境。</p>
<p>在这里插一句嘴说一下Docker Toolbox，它里面集成了一个叫<a href="https://www.docker.com/products/docker-kitematic" target="_blank" rel="external">Kitematic</a>的图形化管理界面，界面很友好。如果不想用命令行来操作Docker，可以用这个玩意儿来管理，效果是一样的。</p>
<p>下载并安装好Docker后，如果你的Hyper-V功能没有开启，Docker会自动帮你开启，并立即重启电脑。Docker For Windows利用了Hyper-V来承载Docker Engine，如果Docker遇到了卡死等重大问题，<del>可以把Hyper-V和下面的镜像卸载重装【大误】</del>……可以在Hyper-V管理器上查看MobyLinuxVM的状态，来确定问题的来源。</p>
<p>个人感觉Docker For Windows不是很稳定，有时候确实需要重启Docker/Hyper-V来解决一部分问题。</p>
</li>
<li><p><strong>第二步，安装Caffe的Docker镜像</strong></p>
<p>根据官方给出的教程，<a href="https://github.com/BVLC/caffe/tree/master/docker" target="_blank" rel="external">https://github.com/BVLC/caffe/tree/master/docker</a></p>
<p>执行以下命令就可以下载并安装对应版本的Docker镜像啦。</p>
<p>CPU 版本可以利用以下命令安装:</p>
<p><code>docker run -ti bvlc/caffe:cpu caffe --version</code></p>
<p>GPU 版本需要CUDA 8.0和相应驱动的支持，还需要配置好<a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external">nvidia-docker</a></p>
<p><code>nvidia-docker run -ti bvlc/caffe:gpu caffe --version</code></p>
<p>忽略libdc1394的相关错误即可。</p>
<p>我安装的是CPU版本，下载镜像和安装比较快，大概需要20分钟左右。下载的时候网络一定要稳定，不然下到一半会卡死，再也走不动。</p>
</li>
<li><p><strong>第三步，熟悉Docker的相关命令</strong></p>
<p>查看（所有的）镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker ps</div><div class="line">docker ps -a</div></pre></td></tr></table></figure>
<p>创建一个基于bash命令行的，新的Caffe容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -ti bvlc/caffe:cpu</div></pre></td></tr></table></figure>
<p>创建一个ipython命令行的，新的Caffe容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -ti bvlc/caffe:cpu ipython</div></pre></td></tr></table></figure>
<p>启动一个已有的容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker start [CONTAINER ID/CONTAINER NAME]</div></pre></td></tr></table></figure>
<p>进入一个正在运行中的容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker attach [CONTAINER ID/CONTAINER NAME]</div></pre></td></tr></table></figure>
<p>删除一个容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm [CONTAINER ID/CONTAINER NAME]</div></pre></td></tr></table></figure>
<p>重命名一个容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rename [CONTAINER NAME] [NEWNAME]</div></pre></td></tr></table></figure>
<p>我们应当先利用<code>docker run</code>命令创建一个自己喜欢的Caffe容器，创建好了之后，我们就已经直接来到这个容器内部了。Caffe在这个时候已经配置好了。</p>
<p>可以在Python命令行当中导入Caffe包，以验证环境配置的有效性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import caffe</div></pre></td></tr></table></figure>
</li>
<li><p><strong>第四步，测试一个简单的LeNet网络</strong></p>
<p>参考官方文档，来测试一下这个环境是不是真的配置好了。</p>
<p><a href="http://caffe.berkeleyvision.org/gathered/examples/mnist.html" target="_blank" rel="external">http://caffe.berkeleyvision.org/gathered/examples/mnist.html</a></p>
<p>首先运行以下命令，从网上把mnist的相关训练数据和测试数据下载下来，然后将数据格式进行转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd $CAFFE_ROOT</div><div class="line">./data/mnist/get_mnist.sh</div><div class="line">./examples/mnist/create_mnist.sh</div></pre></td></tr></table></figure>
<p>容器里面应该是有<code>wget</code>命令的，如果没有，可以用<code>apt-get</code>命令自行解决一下shell脚本的依赖。</p>
<p>卷积神经网络的具体实现，都已经写好了放在示例文件夹当中了。具体路径是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$CAFFE_ROOT/examples/mnist/*.prototxt</div></pre></td></tr></table></figure>
<p>如果只用CPU来跑的话，需要修改<code>lenet_solver.prototxt</code>，将<code>solver_mode</code>从<code>GPU</code>改成<code>CPU</code>。当然，在文件里还可以修改迭代次数等参数，在此按下不表。</p>
<p>当然啦，想要修改文件，得先下载vim……因为我们这个轻量级的容器肯定是不会预装vim的【好理直气壮】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get update</div><div class="line">apt-get install vim</div></pre></td></tr></table></figure>
<p>最后跑一下脚本，卷积神经网络的识别结果就出来啦！迭代10000次，最后的准确率达到了0.991</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd $CAFFE_ROOT</div><div class="line">./examples/mnist/train_lenet.sh</div></pre></td></tr></table></figure>
</li>
</ul>
<p>好玩不！我觉得挺好玩的！然后就这样玩了两个下午……上课的视频还没看，实习的简历还没投，让我去面壁思过一下【捂脸】</p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[CNN与脑部肿瘤分割资料收集]]></title>
      <url>http://wf94.github.io/2017/02/20/CNN-Brain-Tumor-Segmentation/</url>
      <content type="html"><![CDATA[<p>斯坦福大学卷积神经网络教程：</p>
<p><a href="http://ufldl.stanford.edu/tutorial/supervised/ConvolutionalNeuralNetwork/" target="_blank" rel="external">http://ufldl.stanford.edu/tutorial/supervised/ConvolutionalNeuralNetwork/</a></p>
<p><a href="http://ufldl.stanford.edu/wiki/index.php/UFLDL_Tutorial" target="_blank" rel="external">http://ufldl.stanford.edu/wiki/index.php/UFLDL_Tutorial</a></p>
<p><a href="http://ufldl.stanford.edu/tutorial/supervised/FeatureExtractionUsingConvolution/" target="_blank" rel="external">http://ufldl.stanford.edu/tutorial/supervised/FeatureExtractionUsingConvolution/</a></p>
<p>CNN笔记：通俗理解神经网络：</p>
<p><a href="http://blog.csdn.net/v_july_v/article/details/51812459" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/51812459</a></p>
<p>生物医学图像中的深度学习【资料】：</p>
<p><a href="https://madlymissyou.github.io/2016/10/09/deep-learning-for-neuroimage" target="_blank" rel="external">https://madlymissyou.github.io/2016/10/09/deep-learning-for-neuroimage</a></p>
<p>机器学习算法系列：浅析Logistic Regression</p>
<p><a href="https://chenrudan.github.io/blog/2016/01/09/logisticregression.html" target="_blank" rel="external">https://chenrudan.github.io/blog/2016/01/09/logisticregression.html</a></p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[396 Rotate Function]]></title>
      <url>http://wf94.github.io/2017/02/07/396-Rotate-Function/</url>
      <content type="html"><![CDATA[<p>Given an array of integers <code>A</code> and let <em>n</em> to be its length. </p>
<p>Assume <code>Bk</code> to be an array obtained by rotating the array <code>A</code> <em>k</em> positions clock-wise, we define a “rotation function” <code>F</code> on <code>A</code> as follow: </p>
<p><code>F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]</code>.</p>
<p>Calculate the maximum value of <code>F(0), F(1), ..., F(n-1)</code>.  </p>
<p><strong>Note:</strong><br><em>n</em> is guaranteed to be less than 105. </p>
<p><strong>Example:</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">A = [4, 3, 2, 6]</div><div class="line"></div><div class="line">F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25</div><div class="line">F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16</div><div class="line">F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23</div><div class="line">F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26</div><div class="line"></div><div class="line">So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用最简单的方法会超时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxRotateFunction</span><span class="params">(self, A)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type A: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        length  = len(A)</div><div class="line">        res = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            tmp = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(length):</div><div class="line">                tmp += j * A[j-i]</div><div class="line">            res.append(tmp)</div><div class="line">        <span class="keyword">if</span> (len(res)):</div><div class="line">            <span class="keyword">return</span> max(res)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p>把函数变换一下。得到一个关系式，如：</p>
<p>F(1) = F(0) + A数组的和 - (元素个数 * 最后一个元素)</p>
<p>F(2) = F(1) + A数组的和 - (元素个数 * 倒数第二个元素)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxRotateFunction</span><span class="params">(self, A)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type A: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        length  = len(A)</div><div class="line">        <span class="keyword">if</span> (length):</div><div class="line">            suma = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> A:</div><div class="line">                suma += i</div><div class="line">            res = []</div><div class="line">            cur = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">                cur += A[i] * i</div><div class="line">            res.append(cur)</div><div class="line">            </div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-1</span>):</div><div class="line">                prev = res[<span class="number">-1</span>]</div><div class="line">                cur = prev + suma - (A[-i<span class="number">-1</span>] * length)</div><div class="line">                res.append(cur)</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> max(res)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[378 Kth Smallest Element in a Sorted Matrix]]></title>
      <url>http://wf94.github.io/2017/02/06/378-Kth-Smallest-Element-in-a-Sorted-Matrix/</url>
      <content type="html"><![CDATA[<p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element. </p>
<p><strong>Example:</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">matrix = [</div><div class="line">   [ 1,  5,  9],</div><div class="line">   [10, 11, 13],</div><div class="line">   [12, 13, 15]</div><div class="line">],</div><div class="line">k = 8,</div><div class="line"></div><div class="line">return 13.</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>采用了一个最暴力的方法，把每一行的元素全部添加到一个一维数组里，然后排一下序。结果幸运地没有超时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix, k)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type matrix: List[List[int]]</div><div class="line">        :type k: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        stride = []</div><div class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> matrix:</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> m:</div><div class="line">                stride.append(i)</div><div class="line">        stride.sort()</div><div class="line">        <span class="keyword">return</span> stride[k<span class="number">-1</span>]</div></pre></td></tr></table></figure>
<p>这道题用二分法更加省时间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix, k)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    :type matrix: List[List[int]]</div><div class="line">    :type k: int</div><div class="line">    :rtype: int</div><div class="line">    """</div><div class="line">    high = matrix[<span class="number">-1</span>][<span class="number">-1</span>]</div><div class="line">    low = matrix[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">    mid = <span class="number">0</span></div><div class="line">    <span class="keyword">if</span> (high == low):</div><div class="line">        mid = high</div><div class="line">    count = <span class="number">0</span></div><div class="line">    <span class="comment"># 注意要取不等号，而不是小于号；</span></div><div class="line">    <span class="keyword">while</span>( mid != low <span class="keyword">or</span> low != high ):</div><div class="line">        </div><div class="line">        mid = ( high + low ) / <span class="number">2</span></div><div class="line">        <span class="comment"># 统计小于等于k的元素个数</span></div><div class="line">        <span class="keyword">for</span> numbers <span class="keyword">in</span> matrix:</div><div class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</div><div class="line">                <span class="keyword">if</span> (num &lt;= mid):</div><div class="line">                    count += <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (count &gt;= k):</div><div class="line">            high = mid</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># 在这个地方需要把低界+1，因为需要有一个Bias</span></div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">        count = <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> mid</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Binary Search </tag>
            
            <tag> Heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[374 Guess Number Higher or Lower]]></title>
      <url>http://wf94.github.io/2017/02/05/374-Guess-Number-Higher-or-Lower/</url>
      <content type="html"><![CDATA[<p>We are playing the Guess Game. The game is as follows:</p>
<p>I pick a number from <strong>1</strong> to <strong>n</strong>. You have to guess which number I picked.</p>
<p>Every time you guess wrong, I’ll tell you whether the number is higher or lower.</p>
<p>You call a pre-defined API <code>guess(int num)</code> which returns 3 possible results (<code>-1</code>, <code>1</code>, or <code>0</code>):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-1 : My number is lower</div><div class="line"> 1 : My number is higher</div><div class="line"> 0 : Congrats! You got it!</div></pre></td></tr></table></figure>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = 10, I pick 6.</div><div class="line">Return 6.</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用二分法进行搜索。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># The guess API is already defined for you.</span></div><div class="line"><span class="comment"># @param num, your guess</span></div><div class="line"><span class="comment"># @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span></div><div class="line"><span class="comment"># def guess(num):</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">guessNumber</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        high = n</div><div class="line">        low = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> (low &lt;= high):</div><div class="line">            mid = low + (high - low) / <span class="number">2</span></div><div class="line">            <span class="keyword">if</span> (guess(mid) == <span class="number">-1</span>):</div><div class="line">                high = mid - <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> (guess(mid) == <span class="number">1</span>):</div><div class="line">                low = mid + <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">return</span> (high + low)/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>参考资料：</p>
<p>Jon Bentley：90%程序员无法正确实现二分查找算法<br><a href="https://www.cnblogs.com/ider/archive/2012/04/01/binary_search.html" target="_blank" rel="external">https://www.cnblogs.com/ider/archive/2012/04/01/binary_search.html</a><br><a href="http://hedengcheng.com/?p=595" target="_blank" rel="external">http://hedengcheng.com/?p=595</a><br><a href="https://research.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html" target="_blank" rel="external">https://research.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[367 Valid Perfect Square]]></title>
      <url>http://wf94.github.io/2017/02/05/367-Valid-Perfect-Square/</url>
      <content type="html"><![CDATA[<p>Given a positive integer <em>num</em>, write a function which returns True if <em>num</em> is a perfect square else False.</p>
<p><strong>Note:</strong> <strong>Do not</strong> use any built-in library function such as <code>sqrt</code>. </p>
<p><strong>Example 1:</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 16</div><div class="line">Returns: True</div></pre></td></tr></table></figure>
<p><strong>Example 2:</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 14</div><div class="line">Returns: False</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一个数是否为完全平方数。如果利用2~num的数对num进行求余，算法复杂度是O(n)，其实很有可能会超时。要防止超时，使用二分法进行搜索，会显得比较省时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPerfectSquare</span><span class="params">(self, num)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type num: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        high = num</div><div class="line">        low = <span class="number">0</span></div><div class="line">        mid = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> (mid != ( high + low ) / <span class="number">2</span>) :</div><div class="line">            mid = ( high + low ) / <span class="number">2</span></div><div class="line">            <span class="keyword">if</span> mid * mid &gt; num:</div><div class="line">                high = mid  + <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> mid * mid == num:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                low = mid</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Math </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[350 Intersection of Two Arrays II]]></title>
      <url>http://wf94.github.io/2017/02/04/350-Intersection-of-Two-Arrays-II/</url>
      <content type="html"><![CDATA[<p>Given two arrays, write a function to compute their intersection. </p>
<p><strong>Example:</strong><br> Given <em>nums1</em> = <code>[1, 2, 2, 1]</code>, <em>nums2</em> = <code>[2, 2]</code>, return <code>[2, 2]</code>. </p>
<p><strong>Note:</strong></p>
<ul>
<li>Each element in the result should appear as many times as it shows in both arrays.</li>
<li>The result can be in any order.</li>
</ul>
<p><strong>Follow up:</strong></p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if <em>nums1</em>‘s size is small compared to <em>nums2</em>‘s size? Which algorithm is better?</li>
<li>What if elements of <em>nums2</em> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先对两个list进行排序，从nums1来开始看，对nums2来进行寻找。</p>
<p>如果找到相同的元素，就把元素记录到结果list当中。因为list是已经排好序了的，所以如果nums2此时的元素比nums1要大，说明nums1的迭代还没有到能够对应nums2位置的部分。反之亦然。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums1: List[int]</div><div class="line">        :type nums2: List[int]</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        result = []</div><div class="line">        pos = <span class="number">0</span></div><div class="line">        len1 = len(nums1)</div><div class="line">        len2 = len(nums2)</div><div class="line">        <span class="keyword">if</span> ((<span class="keyword">not</span> len1) <span class="keyword">or</span> (<span class="keyword">not</span> len2)):</div><div class="line">            <span class="keyword">return</span> result</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            nums1.sort()</div><div class="line">            nums2.sort()</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</div><div class="line">                <span class="keyword">if</span> (pos == len2):</div><div class="line">                    <span class="keyword">break</span></div><div class="line">                <span class="keyword">while</span>(pos &lt; len2):</div><div class="line">                    <span class="keyword">if</span> (i == nums2[pos]):</div><div class="line">                        pos += <span class="number">1</span></div><div class="line">                        result.append(i)</div><div class="line">                        <span class="keyword">break</span></div><div class="line">                    <span class="keyword">elif</span> (i &gt; nums2[pos]):</div><div class="line">                        pos += <span class="number">1</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        <span class="keyword">break</span></div><div class="line">            <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>其实还可以用哈希表来做这道题，比双指针更加简单明了。</p>
<p><a href="https://discuss.leetcode.com/topic/45893/c-hash-table-solution-and-sort-two-pointers-solution-with-time-and-space-complexity" target="_blank" rel="external">https://discuss.leetcode.com/topic/45893/c-hash-table-solution-and-sort-two-pointers-solution-with-time-and-space-complexity</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Sort </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[345 Reverse Vowels of a String]]></title>
      <url>http://wf94.github.io/2017/02/03/345-Reverse-Vowels-of-a-String/</url>
      <content type="html"><![CDATA[<p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p><strong>Example 1:</strong><br> Given s = “hello”, return “holle”. </p>
<p><strong>Example 2:</strong><br> Given s = “leetcode”, return “leotcede”. </p>
<p><strong>Note:</strong><br> The vowels does not include the letter “y”. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求我们将一个字符串其中的元音翻转位置。</p>
<p>可以利用双指针的方式，两头的指针分别访问到一个元音，调换一下两个元音之间的位置。</p>
<p>也可以利用哈希表来进行操作，我们需要记住元音在字符串的相应位置，之后再利用哈希表生成元音对应位置的数组，交换顺序即可。下面的代码就是基于哈希表的。</p>
<p>注意python当中反向遍历可以直接利用切片的方法来进行。如<code>list[::-1]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        vlist = [<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>]</div><div class="line">        vmap = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> pos, i <span class="keyword">in</span> enumerate(s):</div><div class="line">            <span class="keyword">if</span> ( i <span class="keyword">in</span> vlist ):</div><div class="line">                vmap[pos] = str(i)</div><div class="line">        index = vmap.keys()</div><div class="line">        length = len(index)</div><div class="line">        index.sort()</div><div class="line">        </div><div class="line">        value = []</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> index:</div><div class="line">            value.append(vmap[k])</div><div class="line">        slist = list(s)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            slist[index[i]] = value[length-i<span class="number">-1</span>]</div><div class="line">        s = <span class="string">''</span>.join(slist)</div><div class="line">        <span class="keyword">return</span> s</div></pre></td></tr></table></figure>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/linyawen/archive/2012/03/15/2398292.html" target="_blank" rel="external">http://www.cnblogs.com/linyawen/archive/2012/03/15/2398292.html</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[342 Power of Four]]></title>
      <url>http://wf94.github.io/2017/02/02/342-Power-of-Four/</url>
      <content type="html"><![CDATA[<p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4. </p>
<p><strong>Example:</strong><br> Given num = 16, return true. Given num = 5, return false. </p>
<p><strong>Follow up</strong>: Could you solve it without loops/recursion? </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以通过循环或者递归的方法求出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span><span class="params">(self, num)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type num: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">while</span> (num &gt; <span class="number">1</span>):</div><div class="line">                <span class="keyword">if</span> (num % <span class="number">4</span> != <span class="number">0</span>):</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                num = num / <span class="number">4</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>也可以利用位运算的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">4: 100</div><div class="line">3: 011</div><div class="line">4 &amp; 3 = 0</div><div class="line"></div><div class="line">16: 10000</div><div class="line">15: 01111</div><div class="line">16 &amp; 15 = 0</div></pre></td></tr></table></figure>
<p>得到一个判断条件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( (num<span class="number">-1</span>) &amp; num) == <span class="number">0</span> <span class="keyword">and</span> (num<span class="number">-1</span>) % <span class="number">3</span> == <span class="number">0</span></div></pre></td></tr></table></figure>
<p>如果满足这个判断条件，就是四的乘方了。</p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[326 Power of Three]]></title>
      <url>http://wf94.github.io/2017/02/02/326-Power-of-Three/</url>
      <content type="html"><![CDATA[<p>Given an integer, write a function to determine if it is a power of three. </p>
<p><strong>Follow up:</strong><br>​    Could you do it without using any loop / recursion? </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果单纯利用循环，其实还是很好做的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfThree</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>):</div><div class="line">            <span class="keyword">if</span> (n % <span class="number">3</span> != <span class="number">0</span>):</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            n = n / <span class="number">3</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>但是不利用循环的方法实在是想不出来……就看看这篇参考资料吧：</p>
<p><a href="https://discuss.leetcode.com/topic/33536/a-summary-of-all-solutions-new-method-included-at-15-30pm-jan-8th" target="_blank" rel="external">https://discuss.leetcode.com/topic/33536/a-summary-of-all-solutions-new-method-included-at-15-30pm-jan-8th</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[318 Maximum Product of Word Lengths]]></title>
      <url>http://wf94.github.io/2017/02/01/318-Maximum-Product-of-Word-Lengths/</url>
      <content type="html"><![CDATA[<p>Given a string array <code>words</code>, find the maximum value of <code>length(word[i]) * length(word[j])</code> where the two words do not share common letters.    You may assume that each word will contain only lower case letters.    If no such two words exist, return 0. </p>
<p><strong>Example 1:</strong></p>
<p>​    Given <code>[&quot;abcw&quot;, &quot;baz&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;xtfn&quot;, &quot;abcdef&quot;]</code><br>​    Return <code>16</code><br>​    The two words can be <code>&quot;abcw&quot;, &quot;xtfn&quot;</code>. </p>
<p><strong>Example 2:</strong></p>
<p>​    Given <code>[&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;d&quot;, &quot;cd&quot;, &quot;bcd&quot;, &quot;abcd&quot;]</code><br>​    Return <code>4</code><br>​    The two words can be <code>&quot;ab&quot;, &quot;cd&quot;</code>. </p>
<p><strong>Example 3:</strong></p>
<p>​    Given <code>[&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;]</code><br>​    Return <code>0</code><br>​    No such pair of words. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们需要找出字符串数组中，两个没有重复字符的字符串，并且它们的乘积要最大。</p>
<p>我们当然需要统计数组中每一个字符串，字母出现的次数。但是用什么方法来统计呢？如果用哈希表，空间复杂度可能会有点高，毕竟我们只有确定的26个字母。我选择利用<code>alphabet[26]</code>，来存储字母次数的统计量。</p>
<p>其实还有更有技巧的方法，可以把字母统计量用位操作的方式存储在整数当中。利用移位运算给整数的相应位数赋上相应的值即可。</p>
<p>接下来，我们将数组里的数的对应长度，两两相乘；如果不满足题意，就不考虑这个乘积。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> copy</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, words)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type words: List[str]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        stats = []</div><div class="line">        alphabet = []</div><div class="line">        lens = []</div><div class="line">        length = len(words)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</div><div class="line">            alphabet.append(<span class="number">0</span>)</div><div class="line">            </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            tmp = copy.copy(alphabet)</div><div class="line">            stats.append(tmp)</div><div class="line">            </div><div class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words):</div><div class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> word:</div><div class="line">                stats[i][ord(s)-ord(<span class="string">"a"</span>)] += <span class="number">1</span></div><div class="line">            lens.append(len(word))</div><div class="line">        </div><div class="line">        product = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,length):</div><div class="line">                duplicate = <span class="keyword">False</span></div><div class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">26</span>):</div><div class="line">                    <span class="keyword">if</span> (stats[i][k] <span class="keyword">and</span> stats[j][k]):</div><div class="line">                        duplicate = <span class="keyword">True</span></div><div class="line">                        <span class="keyword">break</span></div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (duplicate):</div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    tmpproduct = lens[i] * lens[j]</div><div class="line">                    <span class="keyword">if</span> (tmpproduct &gt; product):</div><div class="line">                        product = tmpproduct</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> product</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[303 Range Sum Query - Immutable]]></title>
      <url>http://wf94.github.io/2017/01/31/303-Range-Sum-Query-Immutable/</url>
      <content type="html"><![CDATA[<p>Given an integer array <em>nums</em>, find the sum of the elements between indices <em>i</em> and <em>j</em> (<em>i</em> ≤ <em>j</em>), inclusive.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Given nums = [-2, 0, 3, -5, 2, -1]</div><div class="line"></div><div class="line">sumRange(0, 2) -&gt; 1</div><div class="line">sumRange(2, 5) -&gt; -1</div><div class="line">sumRange(0, 5) -&gt; -3</div></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><p>You may assume that the array does not change.</p>
</li>
<li><p>There are many calls to <em>sumRange</em> function.</p>
</li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一开始觉得用用暴力算法没啥问题，但是发现超时了。原因是在测试的时候，会多次调用<code>sumRange</code>函数，如果调用n次，数组长度为m，最坏的情况当然是达到了O(n*m)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        """</div><div class="line">        self.n = nums</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type i: int</div><div class="line">        :type j: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        res = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(i,j+<span class="number">1</span>):</div><div class="line">            res += self.n[k]</div><div class="line">        <span class="keyword">return</span> res</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></div><div class="line"><span class="comment"># obj = NumArray(nums)</span></div><div class="line"><span class="comment"># param_1 = obj.sumRange(i,j)</span></div></pre></td></tr></table></figure>
<p>所以我们考虑利用动态规划来降低复杂度。实际上也是一种典型的空间换时间的方法。</p>
<p>另外声明一个数组<code>n</code>。遍历原数组，将当前元素前，所有元素的和，放进数组<code>n</code>对应的位置当中。</p>
<p>这样在每次调用<code>sumRange</code>的时候，复杂度都是O(1)，超时的问题也就解决了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        """</div><div class="line">        self.n = []</div><div class="line">        res = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">            res += i</div><div class="line">            self.n.append(res)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type i: int</div><div class="line">        :type j: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        left = <span class="number">0</span></div><div class="line">        right = <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>):</div><div class="line">            left = self.n[i<span class="number">-1</span>]</div><div class="line">        right = self.n[j]</div><div class="line">        <span class="keyword">return</span> right - left</div><div class="line"></div><div class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></div><div class="line"><span class="comment"># obj = NumArray(nums)</span></div><div class="line"><span class="comment"># param_1 = obj.sumRange(i,j)</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[299 Bulls and Cows]]></title>
      <url>http://wf94.github.io/2017/01/30/299-Bulls-and-Cows/</url>
      <content type="html"><![CDATA[<p>You are playing the following <a href="https://en.wikipedia.org/wiki/Bulls_and_Cows" target="_blank" rel="external">Bulls and Cows</a> game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<p>For example: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Secret number:  &quot;1807&quot;</div><div class="line">Friend&apos;s guess: &quot;7810&quot;</div></pre></td></tr></table></figure>
<p>Hint: <code>1</code> bull and <code>3</code> cows. (The bull is <code>8</code>, the cows are <code>0</code>, <code>1</code> and <code>7</code>.) </p>
<p>Write a function to return a hint according to the secret number and friend’s guess, use <code>A</code> to indicate the bulls and <code>B</code> to indicate the cows. In the above example, your function should return <code>&quot;1A3B&quot;</code>. </p>
<p>Please note that both secret number and friend’s guess may contain duplicate digits, for example: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Secret number:  &quot;1123&quot;</div><div class="line">Friend&apos;s guess: &quot;0111&quot;</div></pre></td></tr></table></figure>
<p>In this case, the 1st <code>1</code> in friend’s guess is a bull, the 2nd or 3rd <code>1</code> is a cow, and your function should return <code>&quot;1A1B&quot;</code>. </p>
<p>You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一个猜数字的游戏。如果一个人猜到了该数字，且数字的位数和数字都正确，便称作“Bull”，如果位数不正确，但是数字正确，称作”Cow“。</p>
<p>理解了题意之后，我们可以考虑利用哈希表的方法来解决这道题。根据题意统计Bull和Cow的个数即可。注意，已经是Bull的数，就不再是Cow了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHint</span><span class="params">(self, secret, guess)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type secret: str</div><div class="line">        :type guess: str</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        length = len(secret)</div><div class="line">        bull = <span class="number">0</span></div><div class="line">        cow = <span class="number">0</span></div><div class="line">        sdict = &#123;&#125;</div><div class="line">        gdict = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> (secret[i] == guess[i]):</div><div class="line">                bull += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> (sdict.has_key(secret[i])):</div><div class="line">                    sdict[secret[i]] += <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    sdict[secret[i]] = <span class="number">1</span></div><div class="line">                    </div><div class="line">                <span class="keyword">if</span> (gdict.has_key(guess[i])):</div><div class="line">                    gdict[guess[i]] += <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    gdict[guess[i]] = <span class="number">1</span></div><div class="line">        </div><div class="line">        skeylist = sdict.keys()</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> skeylist:</div><div class="line">            <span class="keyword">if</span> (gdict.has_key(j)):</div><div class="line">                cow += min(sdict[j], gdict[j])</div><div class="line">                </div><div class="line">        <span class="keyword">return</span> str(bull) + <span class="string">'A'</span> + str(cow) + <span class="string">'B'</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[290 Word Pattern]]></title>
      <url>http://wf94.github.io/2017/01/29/290-Word-Pattern/</url>
      <content type="html"><![CDATA[<p>Given a <code>pattern</code> and a string <code>str</code>, find if <code>str</code> follows the same pattern.</p>
<p> Here <strong>follow</strong> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <strong>non-empty</strong> word in <code>str</code>.</p>
<p><strong>Examples:</strong></p>
<ol>
<li>pattern = <code>&quot;abba&quot;</code>, str = <code>&quot;dog cat cat dog&quot;</code> should return true.</li>
<li>pattern = <code>&quot;abba&quot;</code>, str = <code>&quot;dog cat cat fish&quot;</code> should return false.</li>
<li>pattern = <code>&quot;aaaa&quot;</code>, str = <code>&quot;dog cat cat dog&quot;</code> should return false.</li>
<li>pattern = <code>&quot;abba&quot;</code>, str = <code>&quot;dog dog dog dog&quot;</code> should return false.</li>
</ol>
<p><strong>Notes:</strong><br> You may assume <code>pattern</code> contains only lowercase letters, and <code>str</code> contains lowercase letters separated by a single space. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过将<code>pattern</code>和<code>string</code>放入哈希表中，分别比较可以得出结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span><span class="params">(self, pattern, str)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type pattern: str</div><div class="line">        :type str: str</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        tmp = <span class="string">''</span></div><div class="line">        words = []</div><div class="line">        m = &#123;&#125;</div><div class="line">        <span class="comment"># 可以利用str.split内置函数，</span></div><div class="line">        <span class="comment"># 实现和下面代码一样的分割字符串取单词功能。</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> str:</div><div class="line">            <span class="keyword">if</span> (i == <span class="string">' '</span> <span class="keyword">and</span> tmp != <span class="string">''</span>):</div><div class="line">                words.append(tmp)</div><div class="line">                tmp = <span class="string">''</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                tmp += i</div><div class="line">        words.append(tmp)</div><div class="line">        <span class="comment">###### #### #### #### #### ######</span></div><div class="line">        length = len(pattern)</div><div class="line">        lengthstr = len(words)</div><div class="line">        <span class="keyword">if</span> (length != lengthstr):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment">### #### #### #### ##### #####</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">                <span class="keyword">if</span> (m.has_key(words[i])):</div><div class="line">                    <span class="keyword">if</span> ( m[words[i]] != pattern[i] ):</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    m[words[i]] = pattern[i]</div><div class="line">                    </div><div class="line">            m = &#123;&#125;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">                <span class="keyword">if</span> (m.has_key(pattern[i])):</div><div class="line">                    <span class="keyword">if</span> ( m[pattern[i]] != words[i] ):</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    m[pattern[i]] = words[i]</div><div class="line">        <span class="comment"># 判断Map是否相等，可以直接使用 == 符号，而不需要用上面复杂的推导</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[278 First Bad Version]]></title>
      <url>http://wf94.github.io/2017/01/28/278-First-Bad-Version/</url>
      <content type="html"><![CDATA[<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.  </p>
<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad. </p>
<p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><code>bool isBadVersion(version)</code>这个函数已经以API的形式给出。我们利用二分法搜索即可得到结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></div><div class="line"><span class="comment"># @param version, an integer</span></div><div class="line"><span class="comment"># @return a bool</span></div><div class="line"><span class="comment"># def isBadVersion(version):</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        low = <span class="number">0</span></div><div class="line">        high = n</div><div class="line">        mid = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt;= mid &lt;= n:</div><div class="line">            mid = low + (high - low) / <span class="number">2</span></div><div class="line">            <span class="keyword">if</span> isBadVersion(mid):</div><div class="line">                <span class="keyword">if</span> mid == <span class="number">0</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">if</span> isBadVersion(mid<span class="number">-1</span>):</div><div class="line">                        high = mid</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        <span class="keyword">return</span> mid</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                low = mid + <span class="number">1</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[268 Missing Number]]></title>
      <url>http://wf94.github.io/2017/01/27/268-Missing-Number/</url>
      <content type="html"><![CDATA[<p>Given an array containing <em>n</em> distinct numbers taken from <code>0, 1, 2, ..., n</code>, find the one that is missing from the array. </p>
<p>For example,<br> Given <em>nums</em> = <code>[0, 1, 3]</code> return <code>2</code>. </p>
<p><strong>Note</strong>:<br> Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找到连续数组当中缺失的那个数。</p>
<p>要想实现O(1)的空间复杂度，可以利用等差数列公式，将数组的和与等差数列的和进行比较即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        add = <span class="number">0</span></div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">            add += i</div><div class="line">        </div><div class="line">        should = ( (<span class="number">1</span> + length) * length ) / <span class="number">2</span></div><div class="line">        </div><div class="line">        <span class="keyword">return</span> should - add</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[257 Binary Tree Paths]]></title>
      <url>http://wf94.github.io/2017/01/26/257-Binary-Tree-Paths/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return all root-to-leaf paths. </p>
<p>For example, given the following binary tree: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   1</div><div class="line"> /   \</div><div class="line">2     3</div><div class="line"> \</div><div class="line">  5</div></pre></td></tr></table></figure>
<p>All root-to-leaf paths are: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用深度优先遍历，可以得到树从根节点到叶子节点的所有路径。递归直到访问到叶子节点，此时向结果数组加入一个路径的字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param &#123;TreeNode&#125; root</span></div><div class="line">    <span class="comment"># @return &#123;string[]&#125;</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root)</span>:</span></div><div class="line">        self.res = []</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            self.DFS(root, <span class="string">''</span>)</div><div class="line">            <span class="keyword">return</span> self.res</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> self.res</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self, root, string)</span>:</span></div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            val = root.val</div><div class="line">            string += str(val)</div><div class="line">            <span class="keyword">if</span> (root.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="keyword">None</span>):</div><div class="line">                self.res.append(string)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                string += <span class="string">'-&gt;'</span> </div><div class="line">                self.DFS(root.left, string)</div><div class="line">                self.DFS(root.right, string)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Tree </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[238 Product of Array Except Self]]></title>
      <url>http://wf94.github.io/2017/01/25/238-Product-of-Array-Except-Self/</url>
      <content type="html"><![CDATA[<p>Given an array of <em>n</em> integers where <em>n</em> &gt; 1, <code>nums</code>, return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</p>
<p>Solve it <strong>without division</strong> and in O(<em>n</em>).</p>
<p>For example, given <code>[1,2,3,4]</code>, return <code>[24,12,8,6]</code>. </p>
<p><strong>Follow up:</strong><br> Could you solve it with constant space complexity? (Note: The output array <strong>does not</strong> count as extra space for the purpose of space complexity analysis.)</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要我们求出数组除了当前元素以外的所有数的乘积，不能使用除法，并使用O(n)的时间复杂度。经过一番……很长时间的考虑，也没想出来。</p>
<p>实际上是一个典型的空间换时间的方法，从左往右记录该元素以左（不含该元素）的累乘结果；再从右向左做一次。最后的结果是两组结果对应的乘积。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        left = []</div><div class="line">        right = []</div><div class="line">        ans = []</div><div class="line">        product = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">            left.append(product)</div><div class="line">            product *= i</div><div class="line">        </div><div class="line">        product = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[::<span class="number">-1</span>]:</div><div class="line">            right.append(product)</div><div class="line">            product *= i</div><div class="line">        </div><div class="line">        <span class="keyword">print</span> left</div><div class="line">        <span class="keyword">print</span> right</div><div class="line">        </div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            ans.append(left[i] * right[length<span class="number">-1</span>-i])</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> ans</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Medium </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[234 Palindrome Linked List]]></title>
      <url>http://wf94.github.io/2017/01/24/234-Palindrome-Linked-List/</url>
      <content type="html"><![CDATA[<p>Given a singly linked list, determine if it is a palindrome.</p>
<p><strong>Follow up:</strong><br> Could you do it in O(n) time and O(1) space?</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最简单的方法当然是把链表里面的所有元素放在数组里，然后就可以判断这个链表是不是回文的了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        cur = head</div><div class="line">        res = []</div><div class="line">        <span class="keyword">while</span> (cur):</div><div class="line">            res.append(cur.val)</div><div class="line">            cur = cur.next</div><div class="line">        length = len(res)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> (res[i] != res[-i<span class="number">-1</span>]):</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>其实还可以利用快慢指针，找到链表的中点；与此同时，慢指针将链表前一半进行反转。之后，再逐节点进行比较，判断链表是否为回文。</p>
<p>但是有人指出，反转链表并不能使得空间复杂度为O(1)。具体请参见：</p>
<p><a href="https://discuss.leetcode.com/topic/18533/reversing-a-list-is-not-considered-o-1-space" target="_blank" rel="external">https://discuss.leetcode.com/topic/18533/reversing-a-list-is-not-considered-o-1-space</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[230 Kth Smallest Element in a BST]]></title>
      <url>http://wf94.github.io/2017/01/24/230-Kth-Smallest-Element-in-a-BST/</url>
      <content type="html"><![CDATA[<p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p>
<p><strong>Note: </strong><br> You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p><strong>Follow up:</strong><br> What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<p><strong>Hint:</strong></p>
<ol>
<li><p>Try to utilize the property of a BST.</p>
</li>
<li><p>What if you could modify the BST node’s structure?</p>
</li>
<li><p>The optimal runtime complexity is O(height of BST).</p>
</li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据平衡二叉树的性质，对平衡二叉树中序遍历，生成的数组是升序的。</p>
<p>所以利用深度优先遍历，将中序遍历的第k个结果输出即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :type k: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        self.res = []</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            self.search(root, k)</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> self.res[<span class="number">-1</span>]</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, cur, k)</span>:</span></div><div class="line">        <span class="keyword">if</span>(cur.left):</div><div class="line">            self.search(cur.left, k)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (len(self.res) == k):</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.res.append(cur.val)</div><div class="line">            </div><div class="line">        <span class="keyword">if</span>(cur.right):</div><div class="line">            self.search(cur.right, k)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[225 Implement Stack using Queues]]></title>
      <url>http://wf94.github.io/2017/01/23/225-Implement-Stack-using-Queues/</url>
      <content type="html"><![CDATA[<p>Implement the following operations of a stack using queues. </p>
<ul>
<li>push(x) – Push element x onto stack. </li>
<li>pop() – Removes the element on top of the stack. </li>
<li>top() – Get the top element. </li>
<li>empty() – Return whether the stack is empty. </li>
</ul>
<p>Notes:</p>
<ul>
<li>You must use <em>only</em> standard operations of a queue – which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>
<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求我们利用队列来实现栈的操作。</p>
<p>栈是先入先出，队列是先入后出。队列转栈的关键就是获得队列中的第一个元素——而队列中没有这样的内建函数。在设计的时候，我们可以利用两个队列来实现栈的功能。在实现栈的<code>pop</code>指令时，将第一个队列中除了第一个元素的所有元素都倒到第二个队列里。这样我们就取到了第一个队列中的第一个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Queue</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        initialize your data structure here.</div><div class="line">        """</div><div class="line">        self.q1 = Queue.Queue()</div><div class="line">        self.q2 = Queue.Queue()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type x: int</div><div class="line">        :rtype: nothing</div><div class="line">        """</div><div class="line">        self.q1.put(x)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :rtype: nothing</div><div class="line">        """</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">not</span> self.q1.empty()):</div><div class="line">            tmp = self.q1.get()</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> self.q1.empty()):</div><div class="line">                self.q2.put(tmp)</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">not</span> self.q2.empty()):</div><div class="line">            self.q1.put(self.q2.get())</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        tmp = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">not</span> self.q1.empty()):</div><div class="line">            tmp = self.q1.get()</div><div class="line">            self.q2.put(tmp)</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">not</span> self.q2.empty()):</div><div class="line">            self.q1.put(self.q2.get())</div><div class="line">        <span class="keyword">return</span> tmp</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">return</span> self.q1.empty()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[219 Contains Duplicate II]]></title>
      <url>http://wf94.github.io/2017/01/22/219-Contains-Duplicate-II/</url>
      <content type="html"><![CDATA[<p>Given an array of integers and an integer <em>k</em>, find out whether there are two distinct indices <em>i</em> and <em>j</em> in the array such that <strong>nums[i] = nums[j]</strong> and the <strong>absolute</strong> difference between <em>i</em> and <em>j</em> is at most <em>k</em>. </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先想到的是用两个指针，只要两个指针指向的值相等，就求出两个指针指向的值之差。但是这样的操作，其实最后的复杂度相对来说会高一些。另外要注意，题目提到，两个相等的数之间差值是“至多”为k，而不是“恰好“为k。</p>
<p>这一部分代码是之前用两个指针的方法，得到了错误的答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">length = len(nums)</div><div class="line"><span class="keyword">if</span> (k &gt;= len(nums)):</div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length-k):</div><div class="line">        <span class="keyword">if</span>(nums[i] == nums[i+k]):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>需要注意，只要有一组数字满足要求，函数就应该返回真。<br>要想将复杂度降低，需要利用哈希表来进行操作。在遍历数组的时候，同时将数组的数值加入哈希表中，从而可以利用它来求得题意所需的答案。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type k: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        length = len(nums)</div><div class="line">        kmap = &#123;&#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> (kmap.has_key(nums[i])):</div><div class="line">                <span class="keyword">if</span> (i - kmap[nums[i]] &lt;= k):</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    kmap[nums[i]] = i</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                kmap[nums[i]] = i</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[204 Count Primes]]></title>
      <url>http://wf94.github.io/2017/01/21/204-Count-Primes/</url>
      <content type="html"><![CDATA[<p>Count the number of prime numbers less than a non-negative number, <strong>n</strong>.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>Let’s start with a <em>isPrime</em> function. To determine if a number is prime, we need to check if it is not divisible by any number less than <em>n</em>. The runtime complexity of <em>isPrime</em> function would be O(<em>n</em>) and hence counting the total prime numbers up to <em>n</em> would be O(<em>n</em>2). Could we do better?</p>
</li>
<li><p>As we know the number must not be divisible by any number &gt; <em>n</em> / 2, we can immediately cut the total iterations half by dividing only up to <em>n</em> / 2. Could we still do better?</p>
</li>
<li><p>Let’s write down all of 12’s factors:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2 × 6 = 12</div><div class="line">3 × 4 = 12</div><div class="line">4 × 3 = 12</div><div class="line">6 × 2 = 12</div></pre></td></tr></table></figure>
<p>As you can see, calculations of 4 × 3 and 6 × 2 are not necessary. Therefore, we only need to consider factors up to √<em>n</em> because, if <em>n</em> is divisible by some number <em>p</em>, then <em>n</em> = <em>p</em> × <em>q</em> and since <em>p</em> ≤ <em>q</em>, we could derive that <em>p</em> ≤ √<em>n</em>.</p>
<p>Our total runtime has now improved to O(<em>n</em>1.5), which is slightly better. Is there a faster approach?</p>
</li>
</ol>
<ol>
<li><p>The <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="external">Sieve of Eratosthenes</a> is one of the most efficient ways to find all prime numbers up to <em>n</em>. But don’t let that name scare you, I promise that the concept is surprisingly simple.</p>
<p><img src="https://leetcode.com/static/images/solutions/Sieve_of_Eratosthenes_animation.gif" alt="img"></p>
<p>Sieve of Eratosthenes: algorithm steps for primes below 121. “<a href="http://commons.wikimedia.org/wiki/File:Sieve_of_Eratosthenes_animation.gif" target="_blank" rel="external">Sieve of Eratosthenes Animation</a>“ by <a href="http://de.wikipedia.org/wiki/Benutzer:SKopp" target="_blank" rel="external">SKopp</a> is licensed under <a href="http://creativecommons.org/licenses/by/2.0/" target="_blank" rel="external">CC BY 2.0</a>. </p>
<p>We start off with a table of <em>n</em> numbers. Let’s look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 × 2 = 6, 3 × 3 = 9, … must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. What does this tell you? Should you mark off all multiples of 4 as well?</p>
</li>
<li><p>4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 × 2 = 10, 5 × 3 = 15, 5 × 4 = 20, 5 × 5 = 25, … can be marked off. There is a slight optimization here, we do not need to start from 5 × 2 = 10. Where should we start marking off?</p>
</li>
<li><p>In fact, we can mark off multiples of 5 starting at 5 × 5 = 25, because 5 × 2 = 10 was already marked off by multiple of 2, similarly 5 × 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is <em>p</em>, we can always mark off multiples of <em>p</em> starting at <em>p</em>2, then in increments of <em>p</em>: <em>p</em>2 + <em>p</em>, <em>p</em>2 + 2<em>p</em>, … Now what should be the terminating loop condition?</p>
</li>
<li><p>It is easy to say that the terminating loop condition is <em>p</em> &lt; <em>n</em>, which is certainly correct but not efficient. Do you still remember <em>Hint #3</em>?</p>
</li>
</ol>
<p>这也就是官方给出的思路，所以我先试了一下，给出 <em>p</em> ≤ √<em>n</em>的情况，能不能通过。</p>
<p>O(n^1.5), Time limit exceeded. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        count = <span class="number">0</span></div><div class="line">        </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</div><div class="line">            flag = <span class="number">1</span></div><div class="line">            k = <span class="number">2</span></div><div class="line">            <span class="keyword">while</span> (k * k &lt;= i):</div><div class="line">                <span class="keyword">if</span> (i % k == <span class="number">0</span>):</div><div class="line">                    flag = <span class="number">0</span></div><div class="line">                    <span class="keyword">break</span></div><div class="line">                k += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> (flag):</div><div class="line">                count += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> count</div></pre></td></tr></table></figure>
<p>答案显然是不行。</p>
<p>接下来我们试一下图中所给的方法。</p>
<p>要注意，<code>primes</code>数组存储的应当是布尔量而不是普通的整数。如果是普通的整数，会造成<code>memory limit exceed</code>的错误。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        count = <span class="number">0</span></div><div class="line">        primes = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</div><div class="line">            primes.append(<span class="keyword">True</span>)</div><div class="line">        </div><div class="line">        i = <span class="number">2</span></div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (i * i &lt; n):</div><div class="line">            <span class="keyword">if</span> (primes[i] == <span class="keyword">True</span>):</div><div class="line">                k = i</div><div class="line">                <span class="keyword">while</span>(i * k &lt;= n):</div><div class="line">                    <span class="keyword">if</span> (primes[i * k] &gt; <span class="number">0</span>):</div><div class="line">                        primes[i * k] = <span class="keyword">False</span></div><div class="line">                    k += <span class="number">1</span></div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</div><div class="line">            <span class="keyword">if</span> (primes[i] == <span class="keyword">True</span>):</div><div class="line">                count += <span class="number">1</span></div><div class="line">                </div><div class="line">        <span class="keyword">return</span> count</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[203 Remove Linked List Elements ]]></title>
      <url>http://wf94.github.io/2017/01/20/203-Remove-Linked-List-Elements/</url>
      <content type="html"><![CDATA[<p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p>
<p><strong>Example</strong><br><strong>Given:</strong> 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6,  <strong>val</strong> = 6<br><strong>Return:</strong> 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5 </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单的链表删除操作。</p>
<p>一定要搞清楚边界条件：如果删除第一个或者最后一个元素会怎么样。然后问题就迎刃而解了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span><span class="params">(self, head, val)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head: ListNode</div><div class="line">        :type val: int</div><div class="line">        :rtype: ListNode</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (head):</div><div class="line">            cur = head</div><div class="line">            <span class="keyword">while</span> (cur):</div><div class="line">                <span class="keyword">if</span> (cur.val == val):</div><div class="line">                    <span class="keyword">if</span> (cur.next):</div><div class="line">                        head = cur.next</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        head = <span class="keyword">None</span></div><div class="line">                    cur = head</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> (cur):   </div><div class="line">                <span class="keyword">while</span> (cur.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</div><div class="line">                    <span class="keyword">if</span> (cur.next.val == val):</div><div class="line">                        cur.next = cur.next.next</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        cur = cur.next</div><div class="line">                </div><div class="line">        <span class="keyword">return</span> head</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[198 House Robber]]></title>
      <url>http://wf94.github.io/2017/01/19/198-House-Robber/</url>
      <content type="html"><![CDATA[<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题就相当于是给定一个一维数组，不能访问连续的两个元素，还要保证取到的元素之和最大。</p>
<p>我们考虑利用动态规划的方法来做。</p>
<p>首先确定最基本的问题，我们假设街道里的房子放在<code>nums</code>数组里。如果街道里没有房子，或者只有一栋房子，最大值当然是空值或者唯一值。而如果街道里有两栋房子，取收益最大的那栋即可。</p>
<p>现在考虑三栋房子的情况。假设我们已经知道了前两栋房子的最大收益，现在将第三栋房子加入考虑。如果取到了第三栋房子，那么第二栋房子就不能取。所以我们能够得到的最大值，就是<code>nums[1]</code>与<code>nums[3]</code>之和与<code>nums[2]</code>之间的最大值。</p>
<p>如果加入第四栋房子，其实情况也是一样的，我们能够得到的最大值，是<code>nums[2]</code>与<code>nums[1]</code>的最大值，加上<code>nums[4]</code>的值——与<code>nums[3]</code>，也就是第三栋房子的时候取到的最大值之间，所得到的最大值。</p>
<p>这样一来，我们就建立了一个可以一直往下寻找的问题，推出了问题的解决方法。</p>
<p>现在我们需要开一个新的空间来存储我们得到的最大值。直觉上来说，我们就利用一个一维数组，就可以记录这些值。一维数组的每一项，都对应着我们从左到右遍历到该元素之前可以达到的收益最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        median = []</div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">elif</span> (length == <span class="number">1</span>):</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</div><div class="line">        <span class="keyword">elif</span> (length == <span class="number">2</span>):</div><div class="line">            <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            median.append(nums[<span class="number">0</span>])</div><div class="line">            median.append(max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]))</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,length):</div><div class="line">                median.append(max(nums[i] + median[i<span class="number">-2</span>], median[i<span class="number">-1</span>]))</div><div class="line">            <span class="keyword">return</span> median[length<span class="number">-1</span>]</div></pre></td></tr></table></figure>
<p><a href="http://xiadong.info/2016/11/leetcode-198-house-robber/" target="_blank" rel="external">http://xiadong.info/2016/11/leetcode-198-house-robber/</a></p>
<p><a href="http://bookshadow.com/weblog/2015/04/01/leetcode-house-robber/" target="_blank" rel="external">http://bookshadow.com/weblog/2015/04/01/leetcode-house-robber/</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[190 Reverse Bits]]></title>
      <url>http://wf94.github.io/2017/01/18/190-Reverse-Bits/</url>
      <content type="html"><![CDATA[<p>Reverse bits of a given 32 bits unsigned integer.</p>
<p>For example, given input 43261596 (represented in binary as <strong>00000010100101000001111010011100</strong>), return 964176192 (represented in binary as <strong>00111001011110000010100101000000</strong>).</p>
<p><strong>Follow up</strong>:<br> If this function is called many times, how would you optimize it? </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用位操作，将掩码设定为<code>0x80000000</code>，利用左移操作，将每一位由高到低放入list中，再倒转。</p>
<p>在最后生成结果的时候也采用移位的方法，从list中取出每一位，并将结果进行叠加。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param n, an integer</span></div><div class="line">    <span class="comment"># @return an integer</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></div><div class="line">        res = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</div><div class="line">            tmp = n &amp; <span class="number">0x80000000</span></div><div class="line">            tmp = tmp &gt;&gt; <span class="number">31</span></div><div class="line">            res.append(tmp)</div><div class="line">            n = n &lt;&lt; <span class="number">1</span></div><div class="line">        <span class="keyword">print</span> res</div><div class="line"></div><div class="line">        ans = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</div><div class="line">            ans = ans &lt;&lt; <span class="number">1</span></div><div class="line">            ans += res[<span class="number">31</span> - i]</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ans</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[189 Rotate Array]]></title>
      <url>http://wf94.github.io/2017/01/17/189-Rotate-Array/</url>
      <content type="html"><![CDATA[<p>Rotate an array of <em>n</em> elements to the right by <em>k</em> steps.</p>
<p>For example, with <em>n</em> = 7 and <em>k</em> = 3, the array <code>[1,2,3,4,5,6,7]</code> is rotated to <code>[5,6,7,1,2,3,4]</code>. </p>
<p><strong>Note:</strong><br> Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.                                                                                                                                               </p>
<p><strong>Hint:</strong><br> Could you do it in-place with O(1) extra space? </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用Python语言对于list操作的性质，可以得到空间复杂度为O(1)的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type k: int</div><div class="line">        :rtype: void Do not return anything, modify nums in-place instead.</div><div class="line">        """</div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">if</span> (k &gt; length):</div><div class="line">            k = k % length</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length - k):</div><div class="line">            nums.append(nums[<span class="number">0</span>])</div><div class="line">            <span class="keyword">del</span> nums[<span class="number">0</span>]</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[168 Excel Sheet Column Title]]></title>
      <url>http://wf94.github.io/2017/01/16/168-Excel-Sheet-Column-Title/</url>
      <content type="html"><![CDATA[<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1 -&gt; A</div><div class="line">2 -&gt; B</div><div class="line">3 -&gt; C</div><div class="line">...</div><div class="line">26 -&gt; Z</div><div class="line">27 -&gt; AA</div><div class="line">28 -&gt; AB</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>归根到底，这道题就是一个进制转换的问题。只不过把传统的10-&gt;2 / 10-&gt;8 / 8-&gt;16 等等，变成了26进制的转化而已。</p>
<p>注意在python当中，<code>ord()</code>函数用来获取一个字符的ASCII码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution(object):</div><div class="line">    def convertToTitle(self, n):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type n: int</div><div class="line">        :rtype: str</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        res = &quot;&quot;</div><div class="line">        while (n &gt; 0):</div><div class="line">            if (n % 26 != 0):</div><div class="line">                res = chr(n % 26 + ord(&quot;A&quot;) - 1) + res</div><div class="line">                n = n / 26</div><div class="line">            else:</div><div class="line">                res = &quot;Z&quot; + res</div><div class="line">                n = (n / 26) - 1</div><div class="line">        return res</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[165 Compare Version Numbers]]></title>
      <url>http://wf94.github.io/2017/01/15/165-Compare-Version-Numbers/</url>
      <content type="html"><![CDATA[<p>Compare two version numbers <em>version1</em> and <em>version2</em>.<br> If <em>version1</em> &gt; <em>version2</em> return 1, if <em>version1</em> &lt; <em>version2</em> return -1, otherwise return 0.</p>
<p>You may assume that the version strings are non-empty and contain only digits and the <code>.</code> character.<br> The <code>.</code> character does not represent a decimal point and is used to separate number sequences.<br> For instance, <code>2.5</code> is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p>
<p>Here is an example of version numbers ordering:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目其实不难，需要我们去比较版本号。</p>
<p>要注意，版本号和小数不同，可以是诸如<code>major.minor(.build)</code>这样的形式。其中，build号还可以用日期（如<code>1.2.20170101</code>来命名，另外，版本号的排序也有讲究。举例：</p>
<p><code>1.124 &gt; 1.4 &gt; 0.134 &gt; 0.5 &gt; 0.0.2 &gt; 0.0.1</code></p>
<p>弄清楚以上的规律，代码也就好组织了。将所提供的字符串按照规则转换为可以比较的形式即可。在代码中，我利用了list对圆点隔开的每一个数进行存储，从而也可以比较版本号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compareVersion</span><span class="params">(self, version1, version2)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type version1: str</div><div class="line">        :type version2: str</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        v1 = []</div><div class="line">        v2 = []</div><div class="line">        tmp = <span class="string">""</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> version1:</div><div class="line">            <span class="keyword">if</span> (i == <span class="string">"."</span>):</div><div class="line">                v1.append(int(tmp))</div><div class="line">                tmp = <span class="string">""</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                tmp += i</div><div class="line">        v1.append(int(tmp))</div><div class="line">        tmp = <span class="string">""</span></div><div class="line">        </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> version2:</div><div class="line">            <span class="keyword">if</span> (j == <span class="string">"."</span>):</div><div class="line">                v2.append(int(tmp))</div><div class="line">                tmp = <span class="string">""</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                tmp += j</div><div class="line">        v2.append(int(tmp))</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (len(v1) <span class="keyword">and</span> v1[<span class="number">-1</span>] == <span class="number">0</span>):</div><div class="line">            <span class="keyword">del</span> v1[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">while</span> (len(v2) <span class="keyword">and</span> v2[<span class="number">-1</span>] == <span class="number">0</span>):</div><div class="line">            <span class="keyword">del</span> v2[<span class="number">-1</span>]</div><div class="line">        </div><div class="line">        len1 = len(v1)</div><div class="line">        len2 = len(v2)</div><div class="line"></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min(len1,len2)):</div><div class="line">            <span class="keyword">if</span> (v1[i] &gt; v2[i]):</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> (v1[i] &lt; v2[i]):</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">        <span class="keyword">if</span> (len1 == len2):</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">elif</span> (len1 &gt; len2):</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[160 Intersection of Two Linked Lists]]></title>
      <url>http://wf94.github.io/2017/01/14/160-Intersection-of-Two-Linked-Lists/</url>
      <content type="html"><![CDATA[<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A:          a1 → a2</div><div class="line">                   ↘</div><div class="line">                     c1 → c2 → c3</div><div class="line">                   ↗            </div><div class="line">B:     b1 → b2 → b3</div></pre></td></tr></table></figure>
<p>begin to intersect at node c1.</p>
<p><strong>Notes:</strong> </p>
<ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns. </li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先要明白题意，如果两个链表相交，这两个链表也不会再分离开。</p>
<p>从而可以先求出链表的长度。如果两个链表相交，对齐它们的尾部，总会在其中一个节点，两链表的值相同。</p>
<p>根据此思路，从而求出链表值相同的那个节点，即可以满足题意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"># Definition for singly-linked list.</div><div class="line"># class ListNode(object):</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line"></div><div class="line">class Solution(object):</div><div class="line">    def getIntersectionNode(self, headA, headB):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type head1, head1: ListNode</div><div class="line">        :rtype: ListNode</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        curA = headA</div><div class="line">        curB = headB</div><div class="line">        lenA = 0</div><div class="line">        lenB = 0</div><div class="line">        while (curA):</div><div class="line">            curA = curA.next</div><div class="line">            lenA += 1</div><div class="line">        while (curB):</div><div class="line">            curB = curB.next</div><div class="line">            lenB += 1</div><div class="line">            </div><div class="line">        if (curA != curB):</div><div class="line">            return None</div><div class="line">        else:</div><div class="line">            curA = headA</div><div class="line">            curB = headB</div><div class="line">            if (lenA &gt;= lenB):</div><div class="line">                for i in range(lenA-lenB):</div><div class="line">                    curA = curA.next</div><div class="line">            else:</div><div class="line">                for i in range(lenB-lenA):</div><div class="line">                    curB = curB.next</div><div class="line">            while (curA and curB):</div><div class="line">                if (curA == curB):</div><div class="line">                    return curA</div><div class="line">                else:</div><div class="line">                    curA = curA.next</div><div class="line">                    curB = curB.next</div><div class="line">        return None</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[144 Binary Tree Preorder Traversal]]></title>
      <url>http://wf94.github.io/2017/01/13/144-Binary-Tree-Preorder-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p>
<p>For example:<br> Given binary tree <code>{1,#,2,3}</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure>
<p>return <code>[1,2,3]</code>. </p>
<p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求我们将树先序遍历，然后输出结果。</p>
<p>我们可以先简单地利用深度优先遍历，递归地得出结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        self.res = []</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            self.helper(root)</div><div class="line">        <span class="keyword">return</span> self.res</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></div><div class="line">        self.res.append(root.val)</div><div class="line">        <span class="keyword">if</span> (root.left):</div><div class="line">            self.helper(root.left)</div><div class="line">        <span class="keyword">if</span> (root.right):</div><div class="line">            self.helper(root.right)</div></pre></td></tr></table></figure>
<p>如果不用递归的方法，可以利用栈来进行树的先序遍历。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        res = []</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            stack = [root]</div><div class="line">            </div><div class="line">            <span class="keyword">while</span> (stack):</div><div class="line">                cur = stack.pop()</div><div class="line">                res.append(cur.val)</div><div class="line">                <span class="keyword">if</span> (cur.right):</div><div class="line">                    stack.append(cur.right)</div><div class="line">                <span class="keyword">if</span> (cur.left):</div><div class="line">                    stack.append(cur.left)</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Stack </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[141 Linked List Cycle]]></title>
      <url>http://wf94.github.io/2017/01/13/141-Linked-List-Cycle/</url>
      <content type="html"><![CDATA[<p>Given a linked list, determine if it has a cycle in it. </p>
<p>Follow up:<br> Can you solve it without using extra space? </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先尝试最直观的方法，将所有的节点都存起来，感觉上是比较麻烦。至少是O(n^2)的复杂度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution(object):</div><div class="line">    def hasCycle(self, head):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: bool</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        nodes = []</div><div class="line">        cur = head</div><div class="line">        while (cur):</div><div class="line">            nodes.append(cur)</div><div class="line">            if (cur.next):</div><div class="line">                if (cur.next in nodes):</div><div class="line">                    return True</div><div class="line">            cur = cur.next</div><div class="line">        return False</div></pre></td></tr></table></figure>
<p>利用哈希表对于这些节点进行存储，时间开销就会减少了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution(object):</div><div class="line">    def hasCycle(self, head):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: bool</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        nodes = &#123;&#125;</div><div class="line">        cur = head</div><div class="line">        while (cur):</div><div class="line">            nodes[cur] = 1</div><div class="line">            if (cur.next):</div><div class="line">                if (nodes.has_key(cur.next)):</div><div class="line">                    return True</div><div class="line">            cur = cur.next</div><div class="line">        return False</div></pre></td></tr></table></figure></p>
<p>另外，利用快慢指针的方法也非常巧妙。快的指针每次前进两步，慢的指针每次前进一步。如果链表里面有一个环，快慢指针一定会相遇。</p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[125 Valid Palindrome]]></title>
      <url>http://wf94.github.io/2017/01/12/125-Valid-Palindrome/</url>
      <content type="html"><![CDATA[<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. </p>
<p>For example,<br><code>&quot;A man, a plan, a canal: Panama&quot;</code> is a palindrome.<br><code>&quot;race a car&quot;</code> is <em>not</em> a palindrome. </p>
<p><strong>Note:</strong><br> Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>For the purpose of this problem, we define empty string as valid palindrome. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一个字符串是否为回文。注意，空字符串也是回文。</p>
<p>在Python当中，如果对字符串频繁采取+操作，会非常耗时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        s = s.lower()</div><div class="line">        alphabet = <span class="string">"abcdefghijklmnopqrstuvwxyz0123456789"</span></div><div class="line">        res = <span class="string">""</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> (i <span class="keyword">in</span> alphabet):</div><div class="line">            	<span class="comment"># 最花时间的操作是在这儿对于字符串的操作</span></div><div class="line">                <span class="comment"># 在python，list.append()的时间复杂度为O(1)，可以考虑转换为list</span></div><div class="line">                res += i</div><div class="line">        </div><div class="line">        length = len(res)</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> (res[i] != res[-(i+<span class="number">1</span>)]):</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>利用接下来的代码，便不会超时。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        s = s.lower()</div><div class="line">        <span class="comment">#alphabet = "abcdefghijklmnopqrstuvwxyz0123456789"</span></div><div class="line">        res = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> (ord(<span class="string">"a"</span>) &lt;= ord(i) &lt;= ord(<span class="string">"z"</span>) <span class="keyword">or</span> ord(<span class="string">"0"</span>) &lt;= ord(i) &lt;= ord(<span class="string">"9"</span>)):</div><div class="line">                res.append(i)</div><div class="line">        </div><div class="line">        length = len(res)</div><div class="line">        i = <span class="number">0</span></div><div class="line">        j = length - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> ( i &lt; j ):</div><div class="line">            <span class="keyword">if</span> (res[i] != res[j]):</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            i += <span class="number">1</span></div><div class="line">            j -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> String </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[119 Pascal's Triangle II]]></title>
      <url>http://wf94.github.io/2017/01/11/119-Pascal-s-Triangle-II/</url>
      <content type="html"><![CDATA[<p>Given an index <em>k</em>, return the <em>k</em>th row of the Pascal’s triangle.</p>
<p>For example, given <em>k</em> = 3,<br> Return <code>[1,3,3,1]</code>. </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>杨辉三角有许多重要的性质。其中一个，就是它第n行数字代表的含义，恰好是n阶多项式展开的系数之值；推而广之，也就是n的各个组合数的值。因此在这一题中，直接采用求组合数的方法，利用组合数求解的公式即可得到结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type rowIndex: int</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        res = [<span class="number">1</span>]</div><div class="line">        <span class="keyword">if</span> (rowIndex &lt;= <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        <span class="keyword">elif</span> (rowIndex == <span class="number">1</span>):</div><div class="line">            res.append(<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, rowIndex):</div><div class="line">                <span class="comment"># 利用了math类当中的factorial函数求阶乘。</span></div><div class="line">                res.append(math.factorial(rowIndex)/math.factorial(i)/math.factorial(rowIndex-i))</div><div class="line">            res.append(<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> res</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[118 Pascal's Triangle]]></title>
      <url>http://wf94.github.io/2017/01/11/118-Pascal-s-Triangle/</url>
      <content type="html"><![CDATA[<p>Given <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p>
<p>For example, given <em>numRows</em> = 5,<br> Return </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">     [1],</div><div class="line">    [1,1],</div><div class="line">   [1,2,1],</div><div class="line">  [1,3,3,1],</div><div class="line"> [1,4,6,4,1]</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>帕斯卡三角，也就是杨辉三角，有着许多重要的性质。</p>
<p>在本题中，简单地利用该行元素和前一行元素之间的关系，就可以通过迭代的方式求得结果。</p>
<p>在这两行当中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  [1, 2, 1],</div><div class="line">   \ / \ /</div><div class="line">    |   |</div><div class="line">[1, 3 , 3 ,1],</div></pre></td></tr></table></figure>
<p>最后一行除了最左边的1以外，中间两个元素分别可以通过1+2=3求得。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> copy</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type numRows: int</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        res = []</div><div class="line">        row1 = [<span class="number">1</span>]</div><div class="line">        row2 = [<span class="number">1</span>,<span class="number">1</span>]</div><div class="line">        <span class="keyword">if</span> (numRows &lt;= <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        <span class="keyword">elif</span> (numRows == <span class="number">1</span>):</div><div class="line">            res.append(row1)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            res.append(row1)</div><div class="line">            res.append(row2)</div><div class="line">            <span class="comment"># 利用浅拷贝来防止list出现混乱</span></div><div class="line">            <span class="comment"># 其实也完全可以不用</span></div><div class="line">            prev = copy.copy(row2)</div><div class="line">            <span class="keyword">while</span>(numRows &gt; <span class="number">2</span>):</div><div class="line">                row = [<span class="number">1</span>]</div><div class="line">                length = len(prev)</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prev)<span class="number">-1</span>):</div><div class="line">                    row.append(prev[i] + prev[i+<span class="number">1</span>])</div><div class="line">                row.append(<span class="number">1</span>)</div><div class="line">                res.append(row)</div><div class="line">                prev = copy.copy(row)</div><div class="line">                numRows -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[112 Path Sum]]></title>
      <url>http://wf94.github.io/2017/01/10/112-Path-Sum/</url>
      <content type="html"><![CDATA[<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. </p>
<p><code>sum = 22</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">      5</div><div class="line">     / \</div><div class="line">    4   8</div><div class="line">   /   / \</div><div class="line">  11  13  4</div><div class="line"> /  \      \</div><div class="line">7    2      1</div></pre></td></tr></table></figure>
<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这一题也是利用深度优先遍历(DFS)的递归方法来进行查找。</p>
<p>需要注意的是，只有自根节点到叶子节点的路径才算是一条符合题意的路径，其它情况都不需要额外考虑了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, sum)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :type sum: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            <span class="keyword">return</span> self.DFS(root, sum)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self, root, sum)</span>:</span></div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            val = root.val</div><div class="line">            sum -= val</div><div class="line">            <span class="keyword">if</span>(root.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="keyword">None</span>):</div><div class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>):</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> self.DFS(root.left, sum) <span class="keyword">or</span> self.DFS(root.right, sum)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Tree </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[111 Minimum Depth of Binary Tree]]></title>
      <url>http://wf94.github.io/2017/01/09/111-Minimum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用深度优先遍历（DFS），采用递归的方法解决这道问题。</p>
<p>在进行递归的时候，将每次递归的结果存储在数组中，根据题意，返回数组的最小值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    res = []</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            self.res = []</div><div class="line">            self.DFS(root, <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> min(self.res)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self, root, depth)</span>:</span></div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            <span class="keyword">if</span> (root.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="keyword">None</span>):</div><div class="line">                self.res.append(depth)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.DFS(root.left, depth+<span class="number">1</span>)</div><div class="line">                self.DFS(root.right, depth+<span class="number">1</span>)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Tree </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[107 Binary Tree Level Order Traversal II]]></title>
      <url>http://wf94.github.io/2017/01/08/107-Binary-Tree-Level-Order-Traversal-II/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br> Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  3</div><div class="line"> / \</div><div class="line">9  20</div><div class="line">  /  \</div><div class="line"> 15   7</div></pre></td></tr></table></figure>
<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [15,7],</div><div class="line">  [9,20],</div><div class="line">  [3]</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>102题也是一道层次遍历的题。在102题中，题目要求是采用自顶向下的输出方式；而这一题采用了自底向上的输出方式。</p>
<p>由于两道题思路相同，都是在队列访问的时候加入空节点用于分割，就不再赘述了。代码后面附上参考链接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        q = []</div><div class="line">        res = []</div><div class="line">        layer = []</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            q.append(root)</div><div class="line">            q.append(<span class="keyword">None</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> q</div><div class="line">        <span class="keyword">while</span> (len(q) &gt; <span class="number">0</span>):</div><div class="line">            node = q[<span class="number">0</span>]</div><div class="line">            layer.append(q[<span class="number">0</span>])</div><div class="line">            <span class="keyword">del</span> q[<span class="number">0</span>]</div><div class="line">            <span class="keyword">if</span> (node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</div><div class="line">                <span class="keyword">if</span> (node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</div><div class="line">                    q.append(node.left)</div><div class="line">                <span class="keyword">if</span> (node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</div><div class="line">                    q.append(node.right)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                layerval = []</div><div class="line">                <span class="keyword">if</span>(len(q) &gt; <span class="number">0</span>):</div><div class="line">                    q.append(<span class="keyword">None</span>)</div><div class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> layer:</div><div class="line">                        <span class="keyword">if</span> (i):</div><div class="line">                            layerval.append(i.val)</div><div class="line">                    res.append(layerval)</div><div class="line">                    layer = []</div><div class="line">        lastlayer = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> layer:</div><div class="line">            <span class="keyword">if</span> (i):</div><div class="line">                lastlayer.append(i.val)</div><div class="line">        res.append(lastlayer)</div><div class="line">        </div><div class="line">        res.reverse()</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<p>参考链接：<a href="http://www.cnblogs.com/miloyip/archive/2010/05/12/binary_tree_traversal.html" target="_blank" rel="external">http://www.cnblogs.com/miloyip/archive/2010/05/12/binary_tree_traversal.html</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[102 Binary Tree Level Order Traversal]]></title>
      <url>http://wf94.github.io/2017/01/08/102-Binary-Tree-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br> Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  3</div><div class="line"> / \</div><div class="line">9  20</div><div class="line">  /  \</div><div class="line"> 15   7</div></pre></td></tr></table></figure>
<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [3],</div><div class="line">  [9,20],</div><div class="line">  [15,7]</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的层次优先遍历，需要涉及广度优先搜索(BFS)。将节点按层次出入队列可以轻松地输出连续的层次优先遍历结果。但是如果需要对每一层分别进行输出，就比较有技巧了。</p>
<p>比较常用的办法是使用空节点来充当层与层之间的分隔符，在python当中用<code>None</code>来表示。当队头访问到空节点后，队尾相应补充一个空节点，是为下一层的分隔符。需要注意的是，队列当中不能够添加额外的空节点，以防分层错乱；如果访问到树的底部，需要注意不要再添加空节点，以防陷入死循环。</p>
<p>python有自带的Queue（队列）类。在这里我利用list实现了一个简单的Queue，也可以实现同样的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        q = []</div><div class="line">        level = []</div><div class="line">        res = []</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            q.append(root)</div><div class="line">            q.append(<span class="keyword">None</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> q</div><div class="line">        <span class="keyword">while</span>(len(q) &gt; <span class="number">0</span>):</div><div class="line">            node = q[<span class="number">0</span>]</div><div class="line">            level.append(node)</div><div class="line">            <span class="keyword">del</span> q[<span class="number">0</span>]</div><div class="line">            <span class="keyword">if</span>(node):</div><div class="line">                <span class="keyword">if</span>(node.left):</div><div class="line">                    q.append(node.left)</div><div class="line">                <span class="keyword">if</span>(node.right):</div><div class="line">                    q.append(node.right)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                values = []</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> level:</div><div class="line">                    <span class="keyword">if</span> (i):</div><div class="line">                        values.append(i.val)</div><div class="line">                res.append(values)</div><div class="line">                level = []</div><div class="line">                <span class="keyword">if</span>(len(q) &gt; <span class="number">0</span>):</div><div class="line">                    q.append(<span class="keyword">None</span>)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[101 Symmetric Tree]]></title>
      <url>http://wf94.github.io/2017/01/07/101-Symmetric-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    1</div><div class="line">   / \</div><div class="line">  2   2</div><div class="line"> / \ / \</div><div class="line">3  4 4  3</div></pre></td></tr></table></figure>
<p>But the following <code>[1,2,2,null,3,null,3]</code>  is not:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  1</div><div class="line"> / \</div><div class="line">2   2</div><div class="line"> \   \</div><div class="line"> 3    3</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和其它的树相关的题目一样，这道题也可以考虑用DFS来进行搜索。在搜索的过程中，递归地判断左右子树是否符合对称条件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            <span class="keyword">return</span> self.Symmetric(root.left, root.right)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Symmetric</span><span class="params">(self, left, right)</span>:</span></div><div class="line">        <span class="keyword">if</span> (left <span class="keyword">and</span> right):</div><div class="line">            <span class="keyword">if</span> (left.val == right.val):</div><div class="line">                <span class="keyword">return</span> self.Symmetric(left.left, right.right) <span class="keyword">and</span> self.Symmetric(left.right, right.left)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">elif</span> (left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">None</span>):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Tree </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[094 Binary Tree Inorder Traversal]]></title>
      <url>http://wf94.github.io/2017/01/07/094-Binary-Tree-Inorder-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p>
<p>For example:<br> Given binary tree <code>[1,null,2,3]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure>
<p>return <code>[1,3,2]</code>. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求我们中序遍历一棵树。依照题意，应当先访问左子树，之后访问根，最后访问右子树。</p>
<p>利用递归实现起来很容易，利用深度优先遍历(DFS)即可实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        res = []</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            self.DFS(root,res) </div><div class="line">        <span class="keyword">return</span> res</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self, root, res)</span>:</span></div><div class="line">        <span class="keyword">if</span> (root.left):</div><div class="line">            self.DFS(root.left, res)</div><div class="line">        res.append(root.val)</div><div class="line">        <span class="keyword">if</span> (root.right):</div><div class="line">            self.DFS(root.right, res)</div></pre></td></tr></table></figure>
<p>题目又提出了进一步的要求，需要我们使用迭代的方法来解决问题。</p>
<p>一般来说，深度优先的操作可以转换为栈的操作。我们发现不仅需要用栈，还需要利用一个能存访问过节点的数据结构才行，不然就会无限循环访问左子树，无法跳出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        stack = []</div><div class="line">        res = []</div><div class="line">        visit = &#123;&#125;</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            stack.append(root)</div><div class="line">            <span class="keyword">while</span>(len(stack)):</div><div class="line">                <span class="comment"># 在这里要注意加入visited选项，如果访问过该节点，就停止查找。</span></div><div class="line">                <span class="keyword">while</span> (stack[<span class="number">-1</span>].left <span class="keyword">and</span> <span class="keyword">not</span> visit.has_key(stack[<span class="number">-1</span>].left)):</div><div class="line">                    stack.append(stack[<span class="number">-1</span>].left)</div><div class="line">                cur = stack.pop()</div><div class="line">                res.append(cur.val)</div><div class="line">                visit[cur] = <span class="number">0</span></div><div class="line">                <span class="keyword">if</span> (cur.right):</div><div class="line">                    stack.append(cur.right)    </div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Medium </tag>
            
            <tag> Stack </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[088 Merge Sorted Array]]></title>
      <url>http://wf94.github.io/2017/01/06/088-Merge-Sorted-Array/</url>
      <content type="html"><![CDATA[<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong><br> You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>. The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这一题要搞清楚题意。利用题意给出的条件在原数组中进行操作即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums1: List[int]</div><div class="line">        :type m: int</div><div class="line">        :type nums2: List[int]</div><div class="line">        :type n: int</div><div class="line">        :rtype: void Do not return anything, modify nums1 in-place instead.</div><div class="line">        """</div><div class="line">        i = m - <span class="number">1</span></div><div class="line">        j = n - <span class="number">1</span></div><div class="line">        k = m + n - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>):</div><div class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums2[j]):</div><div class="line">                nums1[k] = nums1[i]</div><div class="line">                k -= <span class="number">1</span></div><div class="line">                i -= <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                nums1[k] = nums2[j]</div><div class="line">                k -= <span class="number">1</span></div><div class="line">                j -= <span class="number">1</span></div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>):</div><div class="line">            nums1[k] = nums2[j]</div><div class="line">            k -= <span class="number">1</span></div><div class="line">            j -= <span class="number">1</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[069 Sqrt(x)]]></title>
      <url>http://wf94.github.io/2017/01/06/069-Sqrt-x/</url>
      <content type="html"><![CDATA[<p>Implement <code>int sqrt(int x)</code>.</p>
<p>Compute and return the square root of <em>x</em>.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用二分法进行搜索，搜索到的结果进行平方，由此进行比对。</p>
<p>如果需要利用牛顿迭代法解决，最后得到的结果精度都比较高，一般来说是浮点类型的。在这题中，利用二分法可以达到预期的效果。利用牛顿迭代法反而会开销稍大。</p>
<p>在写二分法的时候，千万要注意边界条件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type x: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> x &lt;= <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> x</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            origin = x</div><div class="line">            high = x</div><div class="line">            low = <span class="number">0</span></div><div class="line">            prev = x</div><div class="line">            <span class="keyword">while</span> (prev != (high + low) / <span class="number">2</span>):</div><div class="line">                x = (high + low) / <span class="number">2</span></div><div class="line">                <span class="keyword">if</span> x * x &lt;= origin:</div><div class="line">                    low = x</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="comment"># 注意边界条件</span></div><div class="line">                    high = x + <span class="number">1</span></div><div class="line">                prev = x</div><div class="line">            <span class="keyword">return</span> low</div></pre></td></tr></table></figure>
<p>牛顿迭代法可以参考：<a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots" target="_blank" rel="external">https://en.wikipedia.org/wiki/Methods_of_computing_square_roots</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[067 Add Binary]]></title>
      <url>http://wf94.github.io/2017/01/05/067-Add-Binary/</url>
      <content type="html"><![CDATA[<p>Given two binary strings, return their sum (also a binary string). </p>
<p>For example,<br> a = <code>&quot;11&quot;</code><br> b = <code>&quot;1&quot;</code><br> Return <code>&quot;100&quot;</code>. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意考虑几个条件即可：a和b的长度不同，则位数短的字符串首先停止迭代；注意循环过程中和循环结束后的进位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type a: str</div><div class="line">        :type b: str</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        lena = len(a)</div><div class="line">        lenb = len(b)</div><div class="line"></div><div class="line">        count = summ = carry = <span class="number">0</span></div><div class="line">        result = <span class="string">''</span></div><div class="line">        <span class="keyword">while</span> (count &lt; lena <span class="keyword">or</span> count &lt; lenb):</div><div class="line">            <span class="keyword">if</span> (count &lt; lena <span class="keyword">and</span> count &lt; lenb):</div><div class="line">                summ = int(a[-count<span class="number">-1</span>]) + int(b[-count<span class="number">-1</span>]) + carry</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> (lena &gt; lenb):</div><div class="line">                    summ = int(a[-count<span class="number">-1</span>]) + carry</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    summ = int(b[-count<span class="number">-1</span>]) + carry</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (summ == <span class="number">2</span>):</div><div class="line">                carry = <span class="number">1</span></div><div class="line">                summ = <span class="number">0</span></div><div class="line">            <span class="keyword">elif</span> (summ == <span class="number">3</span>):</div><div class="line">                carry = <span class="number">1</span></div><div class="line">                summ = <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                carry = <span class="number">0</span></div><div class="line">                </div><div class="line">            result = str(summ) + result</div><div class="line">            count += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>):</div><div class="line">            result = str(carry) + result</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[058 Length of Last Word]]></title>
      <url>http://wf94.github.io/2017/01/05/058-Length-of-Last-Word/</url>
      <content type="html"><![CDATA[<p>Given a string <em>s</em> consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p><strong>Note:</strong> A word is defined as a character sequence consists of non-space characters only.</p>
<p>For example,<br> Given <em>s</em> = <code>&quot;Hello World&quot;</code>,<br> return <code>5</code>. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>想办法提取这个字符串所有的单词，然后就可以得到最后一个单词了。关键就是在于空格的处理与分割。需要注意多个空格、开头为空格的情况。</p>
<p>在这里利用了python内置的split方法，也是可行的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (len(s)):</div><div class="line">            l = s.split()</div><div class="line">            <span class="keyword">if</span> (len(l)):</div><div class="line">                <span class="keyword">return</span> len(l[len(l)<span class="number">-1</span>])</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p>P.S. 290题(Word Pattern)涉及到关于空格处理与分割的方法。</p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[053 Maximum Subarray]]></title>
      <url>http://wf94.github.io/2017/01/05/053-Maximum-Subarray/</url>
      <content type="html"><![CDATA[<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum. </p>
<p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br> the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>. </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题可以采用DP的方法来进行思考。遍历数组，访问每一个元素，计算当前元素之前的最大子数列(maximum subarray)的值。</p>
<p>利用两个变量来存储中间值，第一个变量final，存储的是当前的最大子数列(maximum subarray)的和，第二个变量sum，存储的是当前所有元素的非零和。</p>
<p>如果sum小于零，无论如何进行操作，后面的子数列(subarray)单独求和，要优于包含进之前元素的和。所以在计算sum的时候，如果和小于零，则置零。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        sum = <span class="number">0</span></div><div class="line">        final = float(<span class="string">"-inf"</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">            sum += i</div><div class="line">            final = max(sum, final)</div><div class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>):</div><div class="line">                sum = <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> final</div></pre></td></tr></table></figure>
<p>这也是一道经典的问题，该问题最初由布朗大学的Ulf Grenander教授于1977年提出，当初他为了展示数字图像中一个简单的最大然似然估计模型。不久之后卡内基梅隆大学的Jay Kadane提出了该问题的线性算法。上面所用的解法就类似于Kadane算法。</p>
<p>参考：<a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" target="_blank" rel="external">https://en.wikipedia.org/wiki/Maximum_subarray_problem</a></p>
<p>分治算法：<a href="http://xiadong.info/2016/08/leetcode-53-maximum-subarray/" target="_blank" rel="external">http://xiadong.info/2016/08/leetcode-53-maximum-subarray/</a></p>
<p><a href="https://discuss.leetcode.com/topic/426/how-to-solve-maximum-subarray-by-using-the-divide-and-conquer-approach/2" target="_blank" rel="external">https://discuss.leetcode.com/topic/426/how-to-solve-maximum-subarray-by-using-the-divide-and-conquer-approach/2</a></p>
<p>最大子数组问题详解：</p>
<p><a href="http://www.cnblogs.com/zghaobac/p/3315719.html" target="_blank" rel="external">http://www.cnblogs.com/zghaobac/p/3315719.html</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Divide and Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[038 Count and Say]]></title>
      <url>http://wf94.github.io/2017/01/05/038-Count-and-Say/</url>
      <content type="html"><![CDATA[<p>The count-and-say sequence is the sequence of integers beginning as follows:<br><code>1, 11, 21, 1211, 111221, ...</code> </p>
<p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p>
<p>Given an integer <em>n</em>, generate the <em>n</em>th sequence. </p>
<p>Note: The sequence of integers will be represented as a string. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>以1为种子，生成一个符合题意的结果即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        string = <span class="string">'1'</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</div><div class="line">            length = len(string)</div><div class="line">            count = <span class="number">1</span></div><div class="line">            temp = <span class="string">''</span></div><div class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> range(length):</div><div class="line">                <span class="keyword">if</span> (m == length<span class="number">-1</span>):</div><div class="line">                    temp += str(count)</div><div class="line">                    temp += string[m]</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">if</span> (string[m] == string[m+<span class="number">1</span>]):</div><div class="line">                        count += <span class="number">1</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        temp += str(count)</div><div class="line">                        temp += string[m]</div><div class="line">                        count = <span class="number">1</span></div><div class="line">            string = temp</div><div class="line">        <span class="keyword">return</span> string</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[036 Valid Sukodu]]></title>
      <url>http://wf94.github.io/2017/01/04/036-Valid-Sudoku/</url>
      <content type="html"><![CDATA[<p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx" target="_blank" rel="external">Sudoku Puzzles - The Rules</a>.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>&#39;.&#39;</code>.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>需要熟悉数独的规则，利用哈希表来进行判断。</p>
<p>数独的棋盘大小是一定的，不需要考虑时间的耗费，直接利用穷举法把所有情况列举出来，判断数独是否有效。</p>
<p>判断条件是：每一行、每一列、每一个3×3子块，不能有重复的数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type board: List[List[str]]</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        collen = len(board)</div><div class="line">        rowlen = len(board[<span class="number">0</span>])</div><div class="line">        </div><div class="line">        squarelen = <span class="number">3</span></div><div class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> board:</div><div class="line">            linedict = &#123;&#125;</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> line:</div><div class="line">                <span class="keyword">if</span> (i != <span class="string">'.'</span>):</div><div class="line">                    <span class="keyword">if</span> (linedict.has_key(i)):</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        linedict[i] = <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rowlen):</div><div class="line">            rowdict = &#123;&#125;</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(collen):</div><div class="line">                <span class="keyword">if</span> (board[j][i] != <span class="string">'.'</span>):</div><div class="line">                    <span class="keyword">if</span> (rowdict.has_key(board[j][i])):</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        rowdict[board[j][i]] = <span class="number">1</span></div><div class="line">                        </div><div class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>]:</div><div class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>]:</div><div class="line">                squaredict = &#123;&#125;</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(squarelen):</div><div class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(squarelen):</div><div class="line">                        cur = board[i+m][j+n]</div><div class="line">                        <span class="keyword">if</span> (cur != <span class="string">'.'</span>):</div><div class="line">                            <span class="keyword">if</span> (squaredict.has_key(cur)):</div><div class="line">                                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                            <span class="keyword">else</span>:</div><div class="line">                                squaredict[cur] = <span class="number">1</span></div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Medium </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[035 Search Insert Position]]></title>
      <url>http://wf94.github.io/2017/01/04/035-Search-Insert-Position/</url>
      <content type="html"><![CDATA[<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p>Here are few examples.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[1,3,5,6], 5 → 2</div><div class="line">[1,3,5,6], 2 → 1</div><div class="line">[1,3,5,6], 7 → 4</div><div class="line">[1,3,5,6], 0 → 0</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题我就利用O(n)的时间复杂度，鉴于题目难度，时间上还是可以接受的。<br>如果需要优化，可以用二分查找法，在利用二分查找法的时候注意边界条件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type target: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        ans = <span class="number">0</span></div><div class="line">        length = len(nums)</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> target &gt; nums[i]:</div><div class="line">                ans = i + <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> target == nums[i]:</div><div class="line">                ans = i</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">return</span> ans</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[028 Implement strStr]]></title>
      <url>http://wf94.github.io/2017/01/04/028-Implement-strStr/</url>
      <content type="html"><![CDATA[<p>Implement strStr(). </p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出haystack字符串中，needle字符串第一次出现的索引号。</p>
<p>利用两层循环可以得到想要的结果，因为题目难度所限，对于O(n*m)的时间复杂度也没有报超时错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type haystack: str</div><div class="line">        :type needle: str</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        length = len(haystack)</div><div class="line">        lenned = len(needle)</div><div class="line">        <span class="keyword">if</span> (length == lenned <span class="keyword">and</span> length == <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">            </div><div class="line">        <span class="keyword">if</span> (length &lt; lenned):</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">            </div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">                flag = <span class="number">1</span></div><div class="line">                pos = i</div><div class="line">                <span class="comment"># 超出范围，needle不在haystack里</span></div><div class="line">                <span class="keyword">if</span> (pos + lenned &gt; length):</div><div class="line">                    flag = <span class="number">0</span></div><div class="line">                    <span class="keyword">break</span></div><div class="line">                <span class="comment"># 判断needle是不是真的在haystack里</span></div><div class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> needle:</div><div class="line">                    <span class="keyword">if</span> (haystack[pos] != j):</div><div class="line">                        flag = <span class="number">0</span></div><div class="line">                        <span class="keyword">break</span></div><div class="line">                    pos += <span class="number">1</span></div><div class="line">                <span class="comment"># 返回对应的字符串索引</span></div><div class="line">                <span class="keyword">if</span> (flag):</div><div class="line">                    <span class="keyword">return</span> i</div><div class="line">                    </div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[024 Swap Nodes in Pairs]]></title>
      <url>http://wf94.github.io/2017/01/04/024-Swap-Nodes-in-Pairs/</url>
      <content type="html"><![CDATA[<p>Given a linked list, swap every two adjacent nodes and return its head. </p>
<p>For example,<br> Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>. </p>
<p>Your algorithm should use only constant space. You may <strong>not</strong> modify the values in the list, only nodes itself can be changed. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一个单链表的题目，需要对连续两个节点进行操作。需要注意的是，不能改变链表的数值，只能修改结构。</p>
<p>将连接相邻节点的next指针重置即可得到结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</div><div class="line"></div><div class="line">  1 X 2 X 3-&gt;4-&gt;5-&gt;6</div><div class="line"></div><div class="line">  1&lt;-2 X 3-&gt;4-&gt;5-&gt;6</div><div class="line"></div><div class="line"> -&gt;2-&gt;1-&gt;4.....</div></pre></td></tr></table></figure>
<p>将2指向1，1指向4，即完成一次转换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: ListNode</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (head <span class="keyword">and</span> head.next):</div><div class="line">            cur1 = head</div><div class="line">            cur2 = <span class="keyword">None</span></div><div class="line">            cur3 = <span class="keyword">None</span></div><div class="line">            <span class="comment"># 用来指示是否是第一次操作，如果是，</span></div><div class="line">            <span class="comment"># 还需要更改头节点的指向，让头节点指向第二个节点</span></div><div class="line">            firsttime = <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> (cur1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</div><div class="line">                cur2 = cur1.next</div><div class="line">                <span class="keyword">if</span> (cur2):</div><div class="line">                    cur3 = cur2.next</div><div class="line">                    <span class="keyword">if</span> (cur2.next <span class="keyword">and</span> cur2.next.next):</div><div class="line">                        cur1.next = cur2.next.next</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        cur1.next = cur2.next</div><div class="line">                    cur2.next = cur1</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    cur3 = <span class="keyword">None</span></div><div class="line">                <span class="keyword">if</span> (firsttime):</div><div class="line">                    head = cur2</div><div class="line">                cur1 = cur3</div><div class="line">                firsttime = <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> head</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[020 Valid Parentheses]]></title>
      <url>http://wf94.github.io/2017/01/03/020-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<p>Given a string containing just the characters (), [], {}, determine if the input string is valid.</p>
<p>The brackets must close in the correct order.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在考虑这样的题目的时候，边界条件一定要判断清楚。首先，不是说任意一对括号相配对就可以了，还需要考虑括号的种类；其次，括号的配对不能错位嵌套。</p>
<p>本题利用堆栈可以很容易解决。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        p = []</div><div class="line">        flag = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> (i == <span class="string">'('</span> <span class="keyword">or</span> i == <span class="string">'['</span> <span class="keyword">or</span> i == <span class="string">'&#123;'</span>):</div><div class="line">                p.append(i)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> (len(p)):       </div><div class="line">                    j = p.pop()</div><div class="line">                    <span class="comment"># ord函数可以获得该符号的ASCII码</span></div><div class="line">                    <span class="keyword">if</span> (ord(i) - ord(j) == <span class="number">1</span> <span class="keyword">or</span> ord(i) - ord(j) == <span class="number">2</span>):</div><div class="line">                        flag = <span class="number">1</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        flag = <span class="number">0</span></div><div class="line">                        <span class="keyword">break</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    flag = <span class="number">0</span></div><div class="line">                    <span class="keyword">break</span></div><div class="line">        <span class="keyword">if</span> (flag <span class="keyword">and</span> len(p) == <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[019 Remove Nth Node From End of List]]></title>
      <url>http://wf94.github.io/2017/01/03/019-Remove-Nth-Node-From-End-of-List/</url>
      <content type="html"><![CDATA[<p>Given a linked list, remove the <em>n</em>th node from the end of list and return its head. Given <em>n</em> will always be valid and try to do this in one pass. </p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</div><div class="line"></div><div class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道非常典型的快慢指针题。双指针的操作在链表中比较常用，这样的操作可以省去频繁对链表进行遍历的开销，非常方便。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head: ListNode</div><div class="line">        :type n: int</div><div class="line">        :rtype: ListNode</div><div class="line">        """</div><div class="line">        fast = head</div><div class="line">        headflag = <span class="number">1</span></div><div class="line">        <span class="comment"># 利用快指针来定位倒数第n个元素</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            fast = fast.next</div><div class="line">        <span class="comment"># 慢指针必须要指到目标元素前一个元素</span></div><div class="line">        <span class="comment"># 才能执行单链表的删除操作</span></div><div class="line">        <span class="keyword">if</span> (fast):</div><div class="line">            fast = fast.next</div><div class="line">            headflag = <span class="number">0</span></div><div class="line">        slow = head</div><div class="line">        <span class="keyword">while</span>(fast):</div><div class="line">            fast = fast.next</div><div class="line">            slow = slow.next</div><div class="line">        <span class="comment"># 经过循环，现在慢指针已经指向目标元素的前一个元素了</span></div><div class="line">        <span class="keyword">if</span> (slow == head):</div><div class="line">            <span class="comment"># 边界条件：如果慢指针还在头部</span></div><div class="line">            <span class="keyword">if</span> (headflag):</div><div class="line">                <span class="comment"># 删除第一个元素</span></div><div class="line">                head = slow.next</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                slow.next = slow.next.next</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            slow.next = slow.next.next</div><div class="line">        <span class="keyword">return</span> head</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[014 Longest Common Prefix]]></title>
      <url>http://wf94.github.io/2017/01/02/014-Longest-Common-Prefix/</url>
      <content type="html"><![CDATA[<p>Write a function to find the longest common prefix string amongst an array of strings. </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意，参数strs是一个string类型的数组。思路很直白，从数组中每一个字符串的起始位置开始搜索并依次进行比较。只要有其中一个字符串在该位置的字符与其它的字符串不同，搜索结束，从而得到字符串数组的最长公共前缀。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type strs: List[str]</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        length = len(strs)</div><div class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="string">''</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            pos = <span class="number">0</span></div><div class="line">            res = <span class="string">''</span></div><div class="line">            <span class="keyword">while</span>(<span class="keyword">True</span>):</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">                    <span class="keyword">if</span> (pos &gt;= len(strs[i])):</div><div class="line">                        <span class="keyword">return</span> res</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        <span class="keyword">if</span> (strs[i][pos] != strs[<span class="number">0</span>][pos]):</div><div class="line">                            <span class="keyword">return</span> res</div><div class="line">                res += strs[<span class="number">0</span>][pos]</div><div class="line">                pos += <span class="number">1</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[009 Palindrome Number]]></title>
      <url>http://wf94.github.io/2017/01/02/009-Palindrome-Number/</url>
      <content type="html"><![CDATA[<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题如果想用类似于第八题的方法，把每一位的数字都存在一个数组里，显然空间开销会比较大，从而与题意不符。因此，在循环当中，利用数学方法将各位对应数字计算出来，直接进行比较，会显得比较简洁。</p>
<p>需要注意的是，负数不是回文数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type x: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> ( x &gt;= <span class="number">0</span> ):</div><div class="line">            digit = <span class="number">0</span></div><div class="line">            i = x  </div><div class="line">            <span class="keyword">while</span>( i &gt; <span class="number">0</span> ):</div><div class="line">                i = i / <span class="number">10</span></div><div class="line">                digit += <span class="number">1</span></div><div class="line">            high = digit</div><div class="line">            low = <span class="number">1</span></div><div class="line">            m = x</div><div class="line">            n = x</div><div class="line">            <span class="keyword">while</span> (high &gt;= low):</div><div class="line">                <span class="keyword">if</span> (m / (<span class="number">10</span> ** (high<span class="number">-1</span>)) != n % <span class="number">10</span>):</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                m = m - ( (<span class="number">10</span> ** (high<span class="number">-1</span>)) * (m / (<span class="number">10</span> ** (high<span class="number">-1</span>))))</div><div class="line">                n = n / <span class="number">10</span></div><div class="line">                high -= <span class="number">1</span></div><div class="line">                low += <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[008 String to Integer (atoi)]]></title>
      <url>http://wf94.github.io/2017/01/02/008-String-to-Integer-atoi/</url>
      <content type="html"><![CDATA[<p>Implement atoi to convert a string to an integer.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>atoi函数的主要功能就是将字符串转换成整数，题目给出了提示，需要我们考虑清楚所有可能的情况。</p>
<p>百密必有一疏，在我写完代码第一次运行的时候，还是漏掉了以下三项：</p>
<ol>
<li>应当去掉尽可能多的空格；</li>
<li>字符串起始可以含有+号，并将此数视为正数；</li>
<li>在数字之后应当可以包含任何字符。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type str: str</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        </div><div class="line">        symbols = [<span class="string">"+"</span>,<span class="string">"-"</span>]</div><div class="line">        numbers = [<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>]</div><div class="line">        length = len(str)</div><div class="line">        symbol = <span class="string">"+"</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        </div><div class="line">        res = []</div><div class="line">        cur = <span class="number">0</span></div><div class="line">        <span class="comment"># 去除一开始的空格</span></div><div class="line">        <span class="keyword">while</span> (str[cur] == <span class="string">" "</span>):</div><div class="line">            cur += <span class="number">1</span></div><div class="line">        <span class="comment"># 判断第一个字符是不是所期待的字符</span></div><div class="line">        <span class="keyword">if</span> ( (str[cur] <span class="keyword">not</span> <span class="keyword">in</span> symbols) <span class="keyword">and</span> (str[cur] <span class="keyword">not</span> <span class="keyword">in</span> numbers) ):</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># 是符号的话，就存起来；否则开始转换成数字</span></div><div class="line">            <span class="keyword">if</span> (str[cur] <span class="keyword">in</span> symbols):</div><div class="line">                symbol = str[cur]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                res.append(str[cur])</div><div class="line">            cur += <span class="number">1</span></div><div class="line">            </div><div class="line">            <span class="comment"># 注意到数字之后还能有别的乱七八糟的符号</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(cur, length):</div><div class="line">                <span class="keyword">if</span> (str[i] <span class="keyword">not</span> <span class="keyword">in</span> numbers):</div><div class="line">                    <span class="keyword">break</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    res.append(str[i])</div><div class="line">        </div><div class="line">        <span class="comment"># 处理转换数字的操作</span></div><div class="line">        reslen = len(res)</div><div class="line">        <span class="keyword">if</span> (reslen &lt;= <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            answer = <span class="number">0</span></div><div class="line">            count = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> res[::<span class="number">-1</span>]:</div><div class="line">                answer += <span class="number">10</span> ** count * int(i)</div><div class="line">                count += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> (symbol == <span class="string">"-"</span>):</div><div class="line">                answer = -answer</div><div class="line">            <span class="comment"># 注意数字不能越界，python的整数范围比int的值要大</span></div><div class="line">            <span class="keyword">if</span> (answer &gt; <span class="number">2147483647</span>):</div><div class="line">                answer = <span class="number">2147483647</span></div><div class="line">            <span class="keyword">elif</span> (answer &lt; <span class="number">-2147483648</span>):</div><div class="line">                answer = <span class="number">-2147483648</span></div><div class="line">            <span class="keyword">return</span> answer</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[007 Reverse Integer]]></title>
      <url>http://wf94.github.io/2017/01/02/007-Reverse-Integer/</url>
      <content type="html"><![CDATA[<p>Reverse digits of an integer.</p>
<p><strong>Example1:</strong>  x =  123,   return  321<br><strong>Example2:</strong>  x = -123,   return -321 </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一次失败的尝试。考虑的情况太多，以至于没有好好地去整合。</p>
<p>必须注意的是，我们需要考虑如果翻转 100 这个数，最后的结果是怎么样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type x: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (x != <span class="number">0</span>):</div><div class="line">            <span class="comment"># 首先不应该加一个判断是否为0的分支，没有意义啊。0也是无所谓符号的嘛</span></div><div class="line">            isNegative = <span class="keyword">False</span></div><div class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>):</div><div class="line">                x = -x</div><div class="line">                isNegative = <span class="keyword">True</span></div><div class="line">            <span class="comment"># 获得每一位的数字具体是多少，放到res里面</span></div><div class="line">            res = []</div><div class="line">            <span class="keyword">while</span> (x &gt; <span class="number">0</span>):</div><div class="line">                res.append(x % <span class="number">10</span>)</div><div class="line">                x = x / <span class="number">10</span></div><div class="line">            <span class="keyword">while</span> (res[<span class="number">0</span>] == <span class="number">0</span>):</div><div class="line">                <span class="keyword">del</span> res[<span class="number">0</span>]</div><div class="line"></div><div class="line">            <span class="comment"># 反向遍历res，结果赋值给ans</span></div><div class="line">            length = len(res)</div><div class="line">            <span class="keyword">if</span> (length):</div><div class="line">                ans = <span class="number">0</span></div><div class="line">                <span class="comment">#可以写成 for i, enum in enumerate(res[::-1])</span></div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">                    ans += res[-(i+<span class="number">1</span>)] * ( <span class="number">10</span> ** i )</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (isNegative):</div><div class="line">                ans = -ans</div><div class="line"></div><div class="line">            <span class="comment">#可以利用python自带的MAXINT/MININT参数</span></div><div class="line">            <span class="keyword">if</span> (ans &lt; <span class="number">-2</span> ** <span class="number">31</span> <span class="keyword">or</span> ans &gt; <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>):</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> ans</div><div class="line"></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p>最后，可以参考一下示例代码，不需要这么多判断分支，也能完成这道题。<br><a href="https://discuss.leetcode.com/topic/6005/shortest-code-possible-in-c" target="_blank" rel="external">https://discuss.leetcode.com/topic/6005/shortest-code-possible-in-c</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int reverse(int x) &#123;</div><div class="line">        long long res = 0;</div><div class="line">        while(x) &#123;</div><div class="line">            res = res*10 + x%10;</div><div class="line">            x /= 10;</div><div class="line">        &#125;</div><div class="line">        return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[006 Zigzag Conversion]]></title>
      <url>http://wf94.github.io/2017/01/01/006-Zigzag-Conversion/</url>
      <content type="html"><![CDATA[<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">P   A   H   N</div><div class="line">A P L S I I G</div><div class="line">Y   I   R</div></pre></td></tr></table></figure>
<p>And then read line by line: “PAHNAPLSIIGYIR”</p>
<p>Write the code that will take a string and make this conversion given a number of rows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">convert(&quot;PAYPALISHIRING&quot;, 3) ==&gt;  &quot;PAHNAPLSIIGYIR&quot;</div></pre></td></tr></table></figure></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先考虑最简单的情况，行数为2的时候，行数为3的时候每一个元素的分布情况。可以发现，元素分布是有规律的。就拿例子而言，第一行的元素之间相隔3个字符，第二行的元素之间相隔1个字符，利用求余操作就可以得到对应关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s, numRows)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :type numRows: int</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        strlist = []</div><div class="line">        length = len(s)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows):</div><div class="line">            strlist.append(<span class="string">""</span>)</div><div class="line">            </div><div class="line">        <span class="keyword">if</span> (numRows != <span class="number">1</span>):</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">                remain = i % (<span class="number">2</span> * (numRows<span class="number">-1</span>) )</div><div class="line">                <span class="keyword">if</span> (remain &gt;= numRows):</div><div class="line">                    remain = (<span class="number">2</span> * (numRows<span class="number">-1</span>) ) - remain</div><div class="line">                strlist[remain] += s[i]</div><div class="line">                </div><div class="line">            res = <span class="string">""</span></div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> strlist:</div><div class="line">                res += k</div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        </div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> s</div></pre></td></tr></table></figure>
<p>下图也可以更好地理解此题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Δ=2n-2    1                           2n-1                         4n-3</div><div class="line">Δ=        2                     2n-2  2n                    4n-4   4n-2</div><div class="line">Δ=        3               2n-3        2n+1              4n-5       .</div><div class="line">Δ=        .           .               .               .            .</div><div class="line">Δ=        .       n+2                 .           3n               .</div><div class="line">Δ=        n-1 n+1                     3n-3    3n-1                 5n-5</div><div class="line">Δ=2n-2    n                           3n-2                         5n-4</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[001 Two Sum]]></title>
      <url>http://wf94.github.io/2017/01/01/001-Two-Sum/</url>
      <content type="html"><![CDATA[<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Given nums = [2, 7, 11, 15], target = 9,</div><div class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line">return [0, 1].</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为题目给出的数组当中一定会有且只有一个解，而且不能重复用一个元素。所以第一层循环用以遍历数组中的元素，第二层循环用以查询此元素之后，是否还有元素满足要求。</p>
<p>因为这一题的难度是easy，所以利用上面所说，类似于穷举的方法就可以直接得到结果，不需要考虑额外的时间复杂度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type target: int</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            remain = target - nums[i]</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, length):</div><div class="line">                <span class="keyword">if</span> (nums[j] == remain):</div><div class="line">                    <span class="keyword">return</span> [i, j]</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
