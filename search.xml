<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[利用Docker配置基础Caffe环境]]></title>
      <url>http://wf94.github.io/2017/02/28/Playing-with-Docker-Caffe/</url>
      <content type="html"><![CDATA[<p><del>闲来无事【划掉！！！】</del>，我听闻Caffe在配置起来超级麻烦，又是编译有问题，又是依赖解决不了，十分棘手。我马上联想起了方便轻量的Docker。为何不利用Docker在自己的笔记本电脑上搭建Caffe来玩玩呢？</p>
<a id="more"></a>
<ul>
<li><p><strong>第一步，配置Docker For Windows</strong></p>
<p>首先我们需要配置好属于自己的轻量级虚拟化环境！</p>
<p>在Docker官网上下载属于自己系统的版本，<a href="https://www.docker.com/products/overview" target="_blank" rel="external">https://www.docker.com/products/overview</a></p>
<p>我的系统是Windows 10 Professional，Docker For Windows正好适合我。如果是Windows 10之前的版本，需要下载Docker Toolbox来安装Docker环境。</p>
<p>在这里插一句嘴说一下Docker Toolbox，它里面集成了一个叫<a href="https://www.docker.com/products/docker-kitematic" target="_blank" rel="external">Kitematic</a>的图形化管理界面，界面很友好。如果不想用命令行来操作Docker，可以用这个玩意儿来管理，效果是一样的。</p>
<p>下载并安装好Docker后，如果你的Hyper-V功能没有开启，Docker会自动帮你开启，并立即重启电脑。Docker For Windows利用了Hyper-V来承载Docker Engine，如果Docker遇到了卡死等重大问题，<del>可以把Hyper-V和下面的镜像卸载重装【大误】</del>……可以在Hyper-V管理器上查看MobyLinuxVM的状态，来确定问题的来源。</p>
<p>个人感觉Docker For Windows不是很稳定，有时候确实需要重启Docker/Hyper-V来解决一部分问题。</p>
</li>
<li><p><strong>第二步，安装Caffe的Docker镜像</strong></p>
<p>根据官方给出的教程，<a href="https://github.com/BVLC/caffe/tree/master/docker" target="_blank" rel="external">https://github.com/BVLC/caffe/tree/master/docker</a></p>
<p>执行以下命令就可以下载并安装对应版本的Docker镜像啦。</p>
<p>CPU 版本可以利用以下命令安装:</p>
<p><code>docker run -ti bvlc/caffe:cpu caffe --version</code></p>
<p>GPU 版本需要CUDA 8.0和相应驱动的支持，还需要配置好<a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external">nvidia-docker</a></p>
<p><code>nvidia-docker run -ti bvlc/caffe:gpu caffe --version</code></p>
<p>忽略libdc1394的相关错误即可。</p>
<p>我安装的是CPU版本，下载镜像和安装比较快，大概需要20分钟左右。下载的时候网络一定要稳定，不然下到一半会卡死，再也走不动。</p>
</li>
<li><p><strong>第三步，熟悉Docker的相关命令</strong></p>
<p>查看（所有的）镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker ps</div><div class="line">docker ps -a</div></pre></td></tr></table></figure>
<p>创建一个基于bash命令行的，新的Caffe容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -ti bvlc/caffe:cpu</div></pre></td></tr></table></figure>
<p>创建一个ipython命令行的，新的Caffe容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -ti bvlc/caffe:cpu ipython</div></pre></td></tr></table></figure>
<p>启动一个已有的容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker start [CONTAINER ID/CONTAINER NAME]</div></pre></td></tr></table></figure>
<p>进入一个正在运行中的容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker attach [CONTAINER ID/CONTAINER NAME]</div></pre></td></tr></table></figure>
<p>删除一个容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm [CONTAINER ID/CONTAINER NAME]</div></pre></td></tr></table></figure>
<p>重命名一个容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rename [CONTAINER NAME] [NEWNAME]</div></pre></td></tr></table></figure>
<p>我们应当先利用<code>docker run</code>命令创建一个自己喜欢的Caffe容器，创建好了之后，我们就已经直接来到这个容器内部了。Caffe在这个时候已经配置好了。</p>
<p>可以在Python命令行当中导入Caffe包，以验证环境配置的有效性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import caffe</div></pre></td></tr></table></figure>
</li>
<li><p><strong>第四步，测试一个简单的LeNet网络</strong></p>
<p>参考官方文档，来测试一下这个环境是不是真的配置好了。</p>
<p><a href="http://caffe.berkeleyvision.org/gathered/examples/mnist.html" target="_blank" rel="external">http://caffe.berkeleyvision.org/gathered/examples/mnist.html</a></p>
<p>首先运行以下命令，从网上把mnist的相关训练数据和测试数据下载下来，然后将数据格式进行转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd $CAFFE_ROOT</div><div class="line">./data/mnist/get_mnist.sh</div><div class="line">./examples/mnist/create_mnist.sh</div></pre></td></tr></table></figure>
<p>容器里面应该是有<code>wget</code>命令的，如果没有，可以用<code>apt-get</code>命令自行解决一下shell脚本的依赖。</p>
<p>卷积神经网络的具体实现，都已经写好了放在示例文件夹当中了。具体路径是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$CAFFE_ROOT/examples/mnist/*.prototxt</div></pre></td></tr></table></figure>
<p>如果只用CPU来跑的话，需要修改<code>lenet_solver.prototxt</code>，将<code>solver_mode</code>从<code>GPU</code>改成<code>CPU</code>。当然，在文件里还可以修改迭代次数等参数，在此按下不表。</p>
<p>当然啦，想要修改文件，得先下载vim……因为我们这个轻量级的容器肯定是不会预装vim的【好理直气壮】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get update</div><div class="line">apt-get install vim</div></pre></td></tr></table></figure>
<p>最后跑一下脚本，卷积神经网络的识别结果就出来啦！迭代10000次，最后的准确率达到了0.991</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd $CAFFE_ROOT</div><div class="line">./examples/mnist/train_lenet.sh</div></pre></td></tr></table></figure>
</li>
</ul>
<p>好玩不！我觉得挺好玩的！然后就这样玩了两个下午……上课的视频还没看，实习的简历还没投，让我去面壁思过一下【捂脸】</p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[CNN与脑部肿瘤分割资料收集]]></title>
      <url>http://wf94.github.io/2017/02/20/CNN-Brain-Tumor-Segmentation/</url>
      <content type="html"><![CDATA[<p>斯坦福大学卷积神经网络教程：</p>
<p><a href="http://ufldl.stanford.edu/tutorial/supervised/ConvolutionalNeuralNetwork/" target="_blank" rel="external">http://ufldl.stanford.edu/tutorial/supervised/ConvolutionalNeuralNetwork/</a></p>
<p><a href="http://ufldl.stanford.edu/wiki/index.php/UFLDL_Tutorial" target="_blank" rel="external">http://ufldl.stanford.edu/wiki/index.php/UFLDL_Tutorial</a></p>
<p><a href="http://ufldl.stanford.edu/tutorial/supervised/FeatureExtractionUsingConvolution/" target="_blank" rel="external">http://ufldl.stanford.edu/tutorial/supervised/FeatureExtractionUsingConvolution/</a></p>
<p>CNN笔记：通俗理解神经网络：</p>
<p><a href="http://blog.csdn.net/v_july_v/article/details/51812459" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/51812459</a></p>
<p>生物医学图像中的深度学习【资料】：</p>
<p><a href="https://madlymissyou.github.io/2016/10/09/deep-learning-for-neuroimage" target="_blank" rel="external">https://madlymissyou.github.io/2016/10/09/deep-learning-for-neuroimage</a></p>
<p>机器学习算法系列：浅析Logistic Regression</p>
<p><a href="https://chenrudan.github.io/blog/2016/01/09/logisticregression.html" target="_blank" rel="external">https://chenrudan.github.io/blog/2016/01/09/logisticregression.html</a></p>
]]></content>
      
        <categories>
            
            <category> Tech </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[234 Palindrome Linked List]]></title>
      <url>http://wf94.github.io/2017/01/24/234-Palindrome-Linked-List/</url>
      <content type="html"><![CDATA[<p>Given a singly linked list, determine if it is a palindrome.</p>
<p><strong>Follow up:</strong><br> Could you do it in O(n) time and O(1) space?</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最简单的方法当然是把链表里面的所有元素放在数组里，然后就可以判断这个链表是不是回文的了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        cur = head</div><div class="line">        res = []</div><div class="line">        <span class="keyword">while</span> (cur):</div><div class="line">            res.append(cur.val)</div><div class="line">            cur = cur.next</div><div class="line">        length = len(res)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> (res[i] != res[-i<span class="number">-1</span>]):</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>其实还可以利用快慢指针，找到链表的中点；与此同时，慢指针将链表前一半进行反转。之后，再逐节点进行比较，判断链表是否为回文。</p>
<p>但是有人指出，反转链表并不能使得空间复杂度为O(1)。具体请参见：</p>
<p><a href="https://discuss.leetcode.com/topic/18533/reversing-a-list-is-not-considered-o-1-space" target="_blank" rel="external">https://discuss.leetcode.com/topic/18533/reversing-a-list-is-not-considered-o-1-space</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[225 Implement Stack using Queues]]></title>
      <url>http://wf94.github.io/2017/01/23/225-Implement-Stack-using-Queues/</url>
      <content type="html"><![CDATA[<p>Implement the following operations of a stack using queues. </p>
<ul>
<li>push(x) – Push element x onto stack. </li>
<li>pop() – Removes the element on top of the stack. </li>
<li>top() – Get the top element. </li>
<li>empty() – Return whether the stack is empty. </li>
</ul>
<p>Notes:</p>
<ul>
<li>You must use <em>only</em> standard operations of a queue – which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>
<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求我们利用队列来实现栈的操作。</p>
<p>栈是先入先出，队列是先入后出。队列转栈的关键就是获得队列中的第一个元素——而队列中没有这样的内建函数。在设计的时候，我们可以利用两个队列来实现栈的功能。在实现栈的<code>pop</code>指令时，将第一个队列中除了第一个元素的所有元素都倒到第二个队列里。这样我们就取到了第一个队列中的第一个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Queue</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        initialize your data structure here.</div><div class="line">        """</div><div class="line">        self.q1 = Queue.Queue()</div><div class="line">        self.q2 = Queue.Queue()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type x: int</div><div class="line">        :rtype: nothing</div><div class="line">        """</div><div class="line">        self.q1.put(x)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :rtype: nothing</div><div class="line">        """</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">not</span> self.q1.empty()):</div><div class="line">            tmp = self.q1.get()</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> self.q1.empty()):</div><div class="line">                self.q2.put(tmp)</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">not</span> self.q2.empty()):</div><div class="line">            self.q1.put(self.q2.get())</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        tmp = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">not</span> self.q1.empty()):</div><div class="line">            tmp = self.q1.get()</div><div class="line">            self.q2.put(tmp)</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">not</span> self.q2.empty()):</div><div class="line">            self.q1.put(self.q2.get())</div><div class="line">        <span class="keyword">return</span> tmp</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">return</span> self.q1.empty()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[219 Contains Duplicate II]]></title>
      <url>http://wf94.github.io/2017/01/22/219-Contains-Duplicate-II/</url>
      <content type="html"><![CDATA[<p>Given an array of integers and an integer <em>k</em>, find out whether there are two distinct indices <em>i</em> and <em>j</em> in the array such that <strong>nums[i] = nums[j]</strong> and the <strong>absolute</strong> difference between <em>i</em> and <em>j</em> is at most <em>k</em>. </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先想到的是用两个指针，只要两个指针指向的值相等，就求出两个指针指向的值之差。但是这样的操作，其实最后的复杂度相对来说会高一些。另外要注意，题目提到，两个相等的数之间差值是“至多”为k，而不是“恰好“为k。</p>
<p>这一部分代码是之前用两个指针的方法，得到了错误的答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">length = len(nums)</div><div class="line"><span class="keyword">if</span> (k &gt;= len(nums)):</div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length-k):</div><div class="line">        <span class="keyword">if</span>(nums[i] == nums[i+k]):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>需要注意，只要有一组数字满足要求，函数就应该返回真。<br>要想将复杂度降低，需要利用哈希表来进行操作。在遍历数组的时候，同时将数组的数值加入哈希表中，从而可以利用它来求得题意所需的答案。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type k: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        length = len(nums)</div><div class="line">        kmap = &#123;&#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> (kmap.has_key(nums[i])):</div><div class="line">                <span class="keyword">if</span> (i - kmap[nums[i]] &lt;= k):</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    kmap[nums[i]] = i</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                kmap[nums[i]] = i</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[204 Count Primes]]></title>
      <url>http://wf94.github.io/2017/01/21/204-Count-Primes/</url>
      <content type="html"><![CDATA[<p>Count the number of prime numbers less than a non-negative number, <strong>n</strong>.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>Let’s start with a <em>isPrime</em> function. To determine if a number is prime, we need to check if it is not divisible by any number less than <em>n</em>. The runtime complexity of <em>isPrime</em> function would be O(<em>n</em>) and hence counting the total prime numbers up to <em>n</em> would be O(<em>n</em>2). Could we do better?</p>
</li>
<li><p>As we know the number must not be divisible by any number &gt; <em>n</em> / 2, we can immediately cut the total iterations half by dividing only up to <em>n</em> / 2. Could we still do better?</p>
</li>
<li><p>Let’s write down all of 12’s factors:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2 × 6 = 12</div><div class="line">3 × 4 = 12</div><div class="line">4 × 3 = 12</div><div class="line">6 × 2 = 12</div></pre></td></tr></table></figure>
<p>As you can see, calculations of 4 × 3 and 6 × 2 are not necessary. Therefore, we only need to consider factors up to √<em>n</em> because, if <em>n</em> is divisible by some number <em>p</em>, then <em>n</em> = <em>p</em> × <em>q</em> and since <em>p</em> ≤ <em>q</em>, we could derive that <em>p</em> ≤ √<em>n</em>.</p>
<p>Our total runtime has now improved to O(<em>n</em>1.5), which is slightly better. Is there a faster approach?</p>
</li>
</ol>
<ol>
<li><p>The <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="external">Sieve of Eratosthenes</a> is one of the most efficient ways to find all prime numbers up to <em>n</em>. But don’t let that name scare you, I promise that the concept is surprisingly simple.</p>
<p><img src="https://leetcode.com/static/images/solutions/Sieve_of_Eratosthenes_animation.gif" alt="img"></p>
<p>Sieve of Eratosthenes: algorithm steps for primes below 121. “<a href="http://commons.wikimedia.org/wiki/File:Sieve_of_Eratosthenes_animation.gif" target="_blank" rel="external">Sieve of Eratosthenes Animation</a>“ by <a href="http://de.wikipedia.org/wiki/Benutzer:SKopp" target="_blank" rel="external">SKopp</a> is licensed under <a href="http://creativecommons.org/licenses/by/2.0/" target="_blank" rel="external">CC BY 2.0</a>. </p>
<p>We start off with a table of <em>n</em> numbers. Let’s look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 × 2 = 6, 3 × 3 = 9, … must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. What does this tell you? Should you mark off all multiples of 4 as well?</p>
</li>
<li><p>4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 × 2 = 10, 5 × 3 = 15, 5 × 4 = 20, 5 × 5 = 25, … can be marked off. There is a slight optimization here, we do not need to start from 5 × 2 = 10. Where should we start marking off?</p>
</li>
<li><p>In fact, we can mark off multiples of 5 starting at 5 × 5 = 25, because 5 × 2 = 10 was already marked off by multiple of 2, similarly 5 × 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is <em>p</em>, we can always mark off multiples of <em>p</em> starting at <em>p</em>2, then in increments of <em>p</em>: <em>p</em>2 + <em>p</em>, <em>p</em>2 + 2<em>p</em>, … Now what should be the terminating loop condition?</p>
</li>
<li><p>It is easy to say that the terminating loop condition is <em>p</em> &lt; <em>n</em>, which is certainly correct but not efficient. Do you still remember <em>Hint #3</em>?</p>
</li>
</ol>
<p>这也就是官方给出的思路，所以我先试了一下，给出 <em>p</em> ≤ √<em>n</em>的情况，能不能通过。</p>
<p>O(n^1.5), Time limit exceeded. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        count = <span class="number">0</span></div><div class="line">        </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</div><div class="line">            flag = <span class="number">1</span></div><div class="line">            k = <span class="number">2</span></div><div class="line">            <span class="keyword">while</span> (k * k &lt;= i):</div><div class="line">                <span class="keyword">if</span> (i % k == <span class="number">0</span>):</div><div class="line">                    flag = <span class="number">0</span></div><div class="line">                    <span class="keyword">break</span></div><div class="line">                k += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> (flag):</div><div class="line">                count += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> count</div></pre></td></tr></table></figure>
<p>答案显然是不行。</p>
<p>接下来我们试一下图中所给的方法。</p>
<p>要注意，<code>primes</code>数组存储的应当是布尔量而不是普通的整数。如果是普通的整数，会造成<code>memory limit exceed</code>的错误。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        count = <span class="number">0</span></div><div class="line">        primes = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</div><div class="line">            primes.append(<span class="keyword">True</span>)</div><div class="line">        </div><div class="line">        i = <span class="number">2</span></div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (i * i &lt; n):</div><div class="line">            <span class="keyword">if</span> (primes[i] == <span class="keyword">True</span>):</div><div class="line">                k = i</div><div class="line">                <span class="keyword">while</span>(i * k &lt;= n):</div><div class="line">                    <span class="keyword">if</span> (primes[i * k] &gt; <span class="number">0</span>):</div><div class="line">                        primes[i * k] = <span class="keyword">False</span></div><div class="line">                    k += <span class="number">1</span></div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</div><div class="line">            <span class="keyword">if</span> (primes[i] == <span class="keyword">True</span>):</div><div class="line">                count += <span class="number">1</span></div><div class="line">                </div><div class="line">        <span class="keyword">return</span> count</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[203 Remove Linked List Elements ]]></title>
      <url>http://wf94.github.io/2017/01/20/203-Remove-Linked-List-Elements/</url>
      <content type="html"><![CDATA[<p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p>
<p><strong>Example</strong><br><strong>Given:</strong> 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6,  <strong>val</strong> = 6<br><strong>Return:</strong> 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5 </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单的链表删除操作。</p>
<p>一定要搞清楚边界条件：如果删除第一个或者最后一个元素会怎么样。然后问题就迎刃而解了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span><span class="params">(self, head, val)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head: ListNode</div><div class="line">        :type val: int</div><div class="line">        :rtype: ListNode</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (head):</div><div class="line">            cur = head</div><div class="line">            <span class="keyword">while</span> (cur):</div><div class="line">                <span class="keyword">if</span> (cur.val == val):</div><div class="line">                    <span class="keyword">if</span> (cur.next):</div><div class="line">                        head = cur.next</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        head = <span class="keyword">None</span></div><div class="line">                    cur = head</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> (cur):   </div><div class="line">                <span class="keyword">while</span> (cur.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</div><div class="line">                    <span class="keyword">if</span> (cur.next.val == val):</div><div class="line">                        cur.next = cur.next.next</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        cur = cur.next</div><div class="line">                </div><div class="line">        <span class="keyword">return</span> head</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[198 House Robber]]></title>
      <url>http://wf94.github.io/2017/01/19/198-House-Robber/</url>
      <content type="html"><![CDATA[<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题就相当于是给定一个一维数组，不能访问连续的两个元素，还要保证取到的元素之和最大。</p>
<p>我们考虑利用动态规划的方法来做。</p>
<p>首先确定最基本的问题，我们假设街道里的房子放在<code>nums</code>数组里。如果街道里没有房子，或者只有一栋房子，最大值当然是空值或者唯一值。而如果街道里有两栋房子，取收益最大的那栋即可。</p>
<p>现在考虑三栋房子的情况。假设我们已经知道了前两栋房子的最大收益，现在将第三栋房子加入考虑。如果取到了第三栋房子，那么第二栋房子就不能取。所以我们能够得到的最大值，就是<code>nums[1]</code>与<code>nums[3]</code>之和与<code>nums[2]</code>之间的最大值。</p>
<p>如果加入第四栋房子，其实情况也是一样的，我们能够得到的最大值，是<code>nums[2]</code>与<code>nums[1]</code>的最大值，加上<code>nums[4]</code>的值——与<code>nums[3]</code>，也就是第三栋房子的时候取到的最大值之间，所得到的最大值。</p>
<p>这样一来，我们就建立了一个可以一直往下寻找的问题，推出了问题的解决方法。</p>
<p>现在我们需要开一个新的空间来存储我们得到的最大值。直觉上来说，我们就利用一个一维数组，就可以记录这些值。一维数组的每一项，都对应着我们从左到右遍历到该元素之前可以达到的收益最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        median = []</div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">elif</span> (length == <span class="number">1</span>):</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</div><div class="line">        <span class="keyword">elif</span> (length == <span class="number">2</span>):</div><div class="line">            <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            median.append(nums[<span class="number">0</span>])</div><div class="line">            median.append(max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]))</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,length):</div><div class="line">                median.append(max(nums[i] + median[i<span class="number">-2</span>], median[i<span class="number">-1</span>]))</div><div class="line">            <span class="keyword">return</span> median[length<span class="number">-1</span>]</div></pre></td></tr></table></figure>
<p><a href="http://xiadong.info/2016/11/leetcode-198-house-robber/" target="_blank" rel="external">http://xiadong.info/2016/11/leetcode-198-house-robber/</a></p>
<p><a href="http://bookshadow.com/weblog/2015/04/01/leetcode-house-robber/" target="_blank" rel="external">http://bookshadow.com/weblog/2015/04/01/leetcode-house-robber/</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[190 Reverse Bits]]></title>
      <url>http://wf94.github.io/2017/01/18/190-Reverse-Bits/</url>
      <content type="html"><![CDATA[<p>Reverse bits of a given 32 bits unsigned integer.</p>
<p>For example, given input 43261596 (represented in binary as <strong>00000010100101000001111010011100</strong>), return 964176192 (represented in binary as <strong>00111001011110000010100101000000</strong>).</p>
<p><strong>Follow up</strong>:<br> If this function is called many times, how would you optimize it? </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用位操作，将掩码设定为<code>0x80000000</code>，利用左移操作，将每一位由高到低放入list中，再倒转。</p>
<p>在最后生成结果的时候也采用移位的方法，从list中取出每一位，并将结果进行叠加。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param n, an integer</span></div><div class="line">    <span class="comment"># @return an integer</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></div><div class="line">        res = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</div><div class="line">            tmp = n &amp; <span class="number">0x80000000</span></div><div class="line">            tmp = tmp &gt;&gt; <span class="number">31</span></div><div class="line">            res.append(tmp)</div><div class="line">            n = n &lt;&lt; <span class="number">1</span></div><div class="line">        <span class="keyword">print</span> res</div><div class="line"></div><div class="line">        ans = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</div><div class="line">            ans = ans &lt;&lt; <span class="number">1</span></div><div class="line">            ans += res[<span class="number">31</span> - i]</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ans</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[189 Rotate Array]]></title>
      <url>http://wf94.github.io/2017/01/17/189-Rotate-Array/</url>
      <content type="html"><![CDATA[<p>Rotate an array of <em>n</em> elements to the right by <em>k</em> steps.</p>
<p>For example, with <em>n</em> = 7 and <em>k</em> = 3, the array <code>[1,2,3,4,5,6,7]</code> is rotated to <code>[5,6,7,1,2,3,4]</code>. </p>
<p><strong>Note:</strong><br> Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.                                                                                                                                               </p>
<p><strong>Hint:</strong><br> Could you do it in-place with O(1) extra space? </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用Python语言对于list操作的性质，可以得到空间复杂度为O(1)的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type k: int</div><div class="line">        :rtype: void Do not return anything, modify nums in-place instead.</div><div class="line">        """</div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">if</span> (k &gt; length):</div><div class="line">            k = k % length</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length - k):</div><div class="line">            nums.append(nums[<span class="number">0</span>])</div><div class="line">            <span class="keyword">del</span> nums[<span class="number">0</span>]</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[168 Excel Sheet Column Title]]></title>
      <url>http://wf94.github.io/2017/01/16/168-Excel-Sheet-Column-Title/</url>
      <content type="html"><![CDATA[<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1 -&gt; A</div><div class="line">2 -&gt; B</div><div class="line">3 -&gt; C</div><div class="line">...</div><div class="line">26 -&gt; Z</div><div class="line">27 -&gt; AA</div><div class="line">28 -&gt; AB</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>归根到底，这道题就是一个进制转换的问题。只不过把传统的10-&gt;2 / 10-&gt;8 / 8-&gt;16 等等，变成了26进制的转化而已。</p>
<p>注意在python当中，<code>ord()</code>函数用来获取一个字符的ASCII码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution(object):</div><div class="line">    def convertToTitle(self, n):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type n: int</div><div class="line">        :rtype: str</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        res = &quot;&quot;</div><div class="line">        while (n &gt; 0):</div><div class="line">            if (n % 26 != 0):</div><div class="line">                res = chr(n % 26 + ord(&quot;A&quot;) - 1) + res</div><div class="line">                n = n / 26</div><div class="line">            else:</div><div class="line">                res = &quot;Z&quot; + res</div><div class="line">                n = (n / 26) - 1</div><div class="line">        return res</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[165 Compare Version Numbers]]></title>
      <url>http://wf94.github.io/2017/01/15/165-Compare-Version-Numbers/</url>
      <content type="html"><![CDATA[<p>Compare two version numbers <em>version1</em> and <em>version2</em>.<br> If <em>version1</em> &gt; <em>version2</em> return 1, if <em>version1</em> &lt; <em>version2</em> return -1, otherwise return 0.</p>
<p>You may assume that the version strings are non-empty and contain only digits and the <code>.</code> character.<br> The <code>.</code> character does not represent a decimal point and is used to separate number sequences.<br> For instance, <code>2.5</code> is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p>
<p>Here is an example of version numbers ordering:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目其实不难，需要我们去比较版本号。</p>
<p>要注意，版本号和小数不同，可以是诸如<code>major.minor(.build)</code>这样的形式。其中，build号还可以用日期（如<code>1.2.20170101</code>来命名，另外，版本号的排序也有讲究。举例：</p>
<p><code>1.124 &gt; 1.4 &gt; 0.134 &gt; 0.5 &gt; 0.0.2 &gt; 0.0.1</code></p>
<p>弄清楚以上的规律，代码也就好组织了。将所提供的字符串按照规则转换为可以比较的形式即可。在代码中，我利用了list对圆点隔开的每一个数进行存储，从而也可以比较版本号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compareVersion</span><span class="params">(self, version1, version2)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type version1: str</div><div class="line">        :type version2: str</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        v1 = []</div><div class="line">        v2 = []</div><div class="line">        tmp = <span class="string">""</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> version1:</div><div class="line">            <span class="keyword">if</span> (i == <span class="string">"."</span>):</div><div class="line">                v1.append(int(tmp))</div><div class="line">                tmp = <span class="string">""</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                tmp += i</div><div class="line">        v1.append(int(tmp))</div><div class="line">        tmp = <span class="string">""</span></div><div class="line">        </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> version2:</div><div class="line">            <span class="keyword">if</span> (j == <span class="string">"."</span>):</div><div class="line">                v2.append(int(tmp))</div><div class="line">                tmp = <span class="string">""</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                tmp += j</div><div class="line">        v2.append(int(tmp))</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (len(v1) <span class="keyword">and</span> v1[<span class="number">-1</span>] == <span class="number">0</span>):</div><div class="line">            <span class="keyword">del</span> v1[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">while</span> (len(v2) <span class="keyword">and</span> v2[<span class="number">-1</span>] == <span class="number">0</span>):</div><div class="line">            <span class="keyword">del</span> v2[<span class="number">-1</span>]</div><div class="line">        </div><div class="line">        len1 = len(v1)</div><div class="line">        len2 = len(v2)</div><div class="line"></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min(len1,len2)):</div><div class="line">            <span class="keyword">if</span> (v1[i] &gt; v2[i]):</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> (v1[i] &lt; v2[i]):</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">        <span class="keyword">if</span> (len1 == len2):</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">elif</span> (len1 &gt; len2):</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[160 Intersection of Two Linked Lists]]></title>
      <url>http://wf94.github.io/2017/01/14/160-Intersection-of-Two-Linked-Lists/</url>
      <content type="html"><![CDATA[<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A:          a1 → a2</div><div class="line">                   ↘</div><div class="line">                     c1 → c2 → c3</div><div class="line">                   ↗            </div><div class="line">B:     b1 → b2 → b3</div></pre></td></tr></table></figure>
<p>begin to intersect at node c1.</p>
<p><strong>Notes:</strong> </p>
<ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns. </li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先要明白题意，如果两个链表相交，这两个链表也不会再分离开。</p>
<p>从而可以先求出链表的长度。如果两个链表相交，对齐它们的尾部，总会在其中一个节点，两链表的值相同。</p>
<p>根据此思路，从而求出链表值相同的那个节点，即可以满足题意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"># Definition for singly-linked list.</div><div class="line"># class ListNode(object):</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line"></div><div class="line">class Solution(object):</div><div class="line">    def getIntersectionNode(self, headA, headB):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type head1, head1: ListNode</div><div class="line">        :rtype: ListNode</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        curA = headA</div><div class="line">        curB = headB</div><div class="line">        lenA = 0</div><div class="line">        lenB = 0</div><div class="line">        while (curA):</div><div class="line">            curA = curA.next</div><div class="line">            lenA += 1</div><div class="line">        while (curB):</div><div class="line">            curB = curB.next</div><div class="line">            lenB += 1</div><div class="line">            </div><div class="line">        if (curA != curB):</div><div class="line">            return None</div><div class="line">        else:</div><div class="line">            curA = headA</div><div class="line">            curB = headB</div><div class="line">            if (lenA &gt;= lenB):</div><div class="line">                for i in range(lenA-lenB):</div><div class="line">                    curA = curA.next</div><div class="line">            else:</div><div class="line">                for i in range(lenB-lenA):</div><div class="line">                    curB = curB.next</div><div class="line">            while (curA and curB):</div><div class="line">                if (curA == curB):</div><div class="line">                    return curA</div><div class="line">                else:</div><div class="line">                    curA = curA.next</div><div class="line">                    curB = curB.next</div><div class="line">        return None</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[144 Binary Tree Preorder Traversal]]></title>
      <url>http://wf94.github.io/2017/01/13/144-Binary-Tree-Preorder-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p>
<p>For example:<br> Given binary tree <code>{1,#,2,3}</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure>
<p>return <code>[1,2,3]</code>. </p>
<p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求我们将树先序遍历，然后输出结果。</p>
<p>我们可以先简单地利用深度优先遍历，递归地得出结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        self.res = []</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            self.helper(root)</div><div class="line">        <span class="keyword">return</span> self.res</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></div><div class="line">        self.res.append(root.val)</div><div class="line">        <span class="keyword">if</span> (root.left):</div><div class="line">            self.helper(root.left)</div><div class="line">        <span class="keyword">if</span> (root.right):</div><div class="line">            self.helper(root.right)</div></pre></td></tr></table></figure>
<p>如果不用递归的方法，可以利用栈来进行树的先序遍历。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        res = []</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            stack = [root]</div><div class="line">            </div><div class="line">            <span class="keyword">while</span> (stack):</div><div class="line">                cur = stack.pop()</div><div class="line">                res.append(cur.val)</div><div class="line">                <span class="keyword">if</span> (cur.right):</div><div class="line">                    stack.append(cur.right)</div><div class="line">                <span class="keyword">if</span> (cur.left):</div><div class="line">                    stack.append(cur.left)</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Tree </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[141 Linked List Cycle]]></title>
      <url>http://wf94.github.io/2017/01/13/141-Linked-List-Cycle/</url>
      <content type="html"><![CDATA[<p>Given a linked list, determine if it has a cycle in it. </p>
<p>Follow up:<br> Can you solve it without using extra space? </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先尝试最直观的方法，将所有的节点都存起来，感觉上是比较麻烦。至少是O(n^2)的复杂度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution(object):</div><div class="line">    def hasCycle(self, head):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: bool</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        nodes = []</div><div class="line">        cur = head</div><div class="line">        while (cur):</div><div class="line">            nodes.append(cur)</div><div class="line">            if (cur.next):</div><div class="line">                if (cur.next in nodes):</div><div class="line">                    return True</div><div class="line">            cur = cur.next</div><div class="line">        return False</div></pre></td></tr></table></figure>
<p>利用哈希表对于这些节点进行存储，时间开销就会减少了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution(object):</div><div class="line">    def hasCycle(self, head):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: bool</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        nodes = &#123;&#125;</div><div class="line">        cur = head</div><div class="line">        while (cur):</div><div class="line">            nodes[cur] = 1</div><div class="line">            if (cur.next):</div><div class="line">                if (nodes.has_key(cur.next)):</div><div class="line">                    return True</div><div class="line">            cur = cur.next</div><div class="line">        return False</div></pre></td></tr></table></figure></p>
<p>另外，利用快慢指针的方法也非常巧妙。快的指针每次前进两步，慢的指针每次前进一步。如果链表里面有一个环，快慢指针一定会相遇。</p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[125 Valid Palindrome]]></title>
      <url>http://wf94.github.io/2017/01/12/125-Valid-Palindrome/</url>
      <content type="html"><![CDATA[<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. </p>
<p>For example,<br><code>&quot;A man, a plan, a canal: Panama&quot;</code> is a palindrome.<br><code>&quot;race a car&quot;</code> is <em>not</em> a palindrome. </p>
<p><strong>Note:</strong><br> Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>For the purpose of this problem, we define empty string as valid palindrome. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断一个字符串是否为回文。注意，空字符串也是回文。</p>
<p>在Python当中，如果对字符串频繁采取+操作，会非常耗时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        s = s.lower()</div><div class="line">        alphabet = <span class="string">"abcdefghijklmnopqrstuvwxyz0123456789"</span></div><div class="line">        res = <span class="string">""</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> (i <span class="keyword">in</span> alphabet):</div><div class="line">            	<span class="comment"># 最花时间的操作是在这儿对于字符串的操作</span></div><div class="line">                <span class="comment"># 在python，list.append()的时间复杂度为O(1)，可以考虑转换为list</span></div><div class="line">                res += i</div><div class="line">        </div><div class="line">        length = len(res)</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> (res[i] != res[-(i+<span class="number">1</span>)]):</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>利用接下来的代码，便不会超时。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        s = s.lower()</div><div class="line">        <span class="comment">#alphabet = "abcdefghijklmnopqrstuvwxyz0123456789"</span></div><div class="line">        res = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> (ord(<span class="string">"a"</span>) &lt;= ord(i) &lt;= ord(<span class="string">"z"</span>) <span class="keyword">or</span> ord(<span class="string">"0"</span>) &lt;= ord(i) &lt;= ord(<span class="string">"9"</span>)):</div><div class="line">                res.append(i)</div><div class="line">        </div><div class="line">        length = len(res)</div><div class="line">        i = <span class="number">0</span></div><div class="line">        j = length - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> ( i &lt; j ):</div><div class="line">            <span class="keyword">if</span> (res[i] != res[j]):</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            i += <span class="number">1</span></div><div class="line">            j -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> String </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[119 Pascal's Triangle II]]></title>
      <url>http://wf94.github.io/2017/01/11/119-Pascal-s-Triangle-II/</url>
      <content type="html"><![CDATA[<p>Given an index <em>k</em>, return the <em>k</em>th row of the Pascal’s triangle.</p>
<p>For example, given <em>k</em> = 3,<br> Return <code>[1,3,3,1]</code>. </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>杨辉三角有许多重要的性质。其中一个，就是它第n行数字代表的含义，恰好是n阶多项式展开的系数之值；推而广之，也就是n的各个组合数的值。因此在这一题中，直接采用求组合数的方法，利用组合数求解的公式即可得到结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type rowIndex: int</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        res = [<span class="number">1</span>]</div><div class="line">        <span class="keyword">if</span> (rowIndex &lt;= <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        <span class="keyword">elif</span> (rowIndex == <span class="number">1</span>):</div><div class="line">            res.append(<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, rowIndex):</div><div class="line">                <span class="comment"># 利用了math类当中的factorial函数求阶乘。</span></div><div class="line">                res.append(math.factorial(rowIndex)/math.factorial(i)/math.factorial(rowIndex-i))</div><div class="line">            res.append(<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> res</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[118 Pascal's Triangle]]></title>
      <url>http://wf94.github.io/2017/01/11/118-Pascal-s-Triangle/</url>
      <content type="html"><![CDATA[<p>Given <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p>
<p>For example, given <em>numRows</em> = 5,<br> Return </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">     [1],</div><div class="line">    [1,1],</div><div class="line">   [1,2,1],</div><div class="line">  [1,3,3,1],</div><div class="line"> [1,4,6,4,1]</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>帕斯卡三角，也就是杨辉三角，有着许多重要的性质。</p>
<p>在本题中，简单地利用该行元素和前一行元素之间的关系，就可以通过迭代的方式求得结果。</p>
<p>在这两行当中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  [1, 2, 1],</div><div class="line">   \ / \ /</div><div class="line">    |   |</div><div class="line">[1, 3 , 3 ,1],</div></pre></td></tr></table></figure>
<p>最后一行除了最左边的1以外，中间两个元素分别可以通过1+2=3求得。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> copy</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type numRows: int</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        res = []</div><div class="line">        row1 = [<span class="number">1</span>]</div><div class="line">        row2 = [<span class="number">1</span>,<span class="number">1</span>]</div><div class="line">        <span class="keyword">if</span> (numRows &lt;= <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        <span class="keyword">elif</span> (numRows == <span class="number">1</span>):</div><div class="line">            res.append(row1)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            res.append(row1)</div><div class="line">            res.append(row2)</div><div class="line">            <span class="comment"># 利用浅拷贝来防止list出现混乱</span></div><div class="line">            <span class="comment"># 其实也完全可以不用</span></div><div class="line">            prev = copy.copy(row2)</div><div class="line">            <span class="keyword">while</span>(numRows &gt; <span class="number">2</span>):</div><div class="line">                row = [<span class="number">1</span>]</div><div class="line">                length = len(prev)</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prev)<span class="number">-1</span>):</div><div class="line">                    row.append(prev[i] + prev[i+<span class="number">1</span>])</div><div class="line">                row.append(<span class="number">1</span>)</div><div class="line">                res.append(row)</div><div class="line">                prev = copy.copy(row)</div><div class="line">                numRows -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[112 Path Sum]]></title>
      <url>http://wf94.github.io/2017/01/10/112-Path-Sum/</url>
      <content type="html"><![CDATA[<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. </p>
<p><code>sum = 22</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">      5</div><div class="line">     / \</div><div class="line">    4   8</div><div class="line">   /   / \</div><div class="line">  11  13  4</div><div class="line"> /  \      \</div><div class="line">7    2      1</div></pre></td></tr></table></figure>
<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这一题也是利用深度优先遍历(DFS)的递归方法来进行查找。</p>
<p>需要注意的是，只有自根节点到叶子节点的路径才算是一条符合题意的路径，其它情况都不需要额外考虑了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, sum)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :type sum: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            <span class="keyword">return</span> self.DFS(root, sum)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self, root, sum)</span>:</span></div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            val = root.val</div><div class="line">            sum -= val</div><div class="line">            <span class="keyword">if</span>(root.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="keyword">None</span>):</div><div class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>):</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> self.DFS(root.left, sum) <span class="keyword">or</span> self.DFS(root.right, sum)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Tree </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[111 Minimum Depth of Binary Tree]]></title>
      <url>http://wf94.github.io/2017/01/09/111-Minimum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用深度优先遍历（DFS），采用递归的方法解决这道问题。</p>
<p>在进行递归的时候，将每次递归的结果存储在数组中，根据题意，返回数组的最小值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    res = []</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            self.res = []</div><div class="line">            self.DFS(root, <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> min(self.res)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self, root, depth)</span>:</span></div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            <span class="keyword">if</span> (root.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="keyword">None</span>):</div><div class="line">                self.res.append(depth)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.DFS(root.left, depth+<span class="number">1</span>)</div><div class="line">                self.DFS(root.right, depth+<span class="number">1</span>)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[107 Binary Tree Level Order Traversal II]]></title>
      <url>http://wf94.github.io/2017/01/08/107-Binary-Tree-Level-Order-Traversal-II/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br> Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  3</div><div class="line"> / \</div><div class="line">9  20</div><div class="line">  /  \</div><div class="line"> 15   7</div></pre></td></tr></table></figure>
<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [15,7],</div><div class="line">  [9,20],</div><div class="line">  [3]</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>102题也是一道层次遍历的题。在102题中，题目要求是采用自顶向下的输出方式；而这一题采用了自底向上的输出方式。</p>
<p>由于两道题思路相同，都是在队列访问的时候加入空节点用于分割，就不再赘述了。代码后面附上参考链接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        q = []</div><div class="line">        res = []</div><div class="line">        layer = []</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            q.append(root)</div><div class="line">            q.append(<span class="keyword">None</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> q</div><div class="line">        <span class="keyword">while</span> (len(q) &gt; <span class="number">0</span>):</div><div class="line">            node = q[<span class="number">0</span>]</div><div class="line">            layer.append(q[<span class="number">0</span>])</div><div class="line">            <span class="keyword">del</span> q[<span class="number">0</span>]</div><div class="line">            <span class="keyword">if</span> (node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</div><div class="line">                <span class="keyword">if</span> (node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</div><div class="line">                    q.append(node.left)</div><div class="line">                <span class="keyword">if</span> (node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</div><div class="line">                    q.append(node.right)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                layerval = []</div><div class="line">                <span class="keyword">if</span>(len(q) &gt; <span class="number">0</span>):</div><div class="line">                    q.append(<span class="keyword">None</span>)</div><div class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> layer:</div><div class="line">                        <span class="keyword">if</span> (i):</div><div class="line">                            layerval.append(i.val)</div><div class="line">                    res.append(layerval)</div><div class="line">                    layer = []</div><div class="line">        lastlayer = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> layer:</div><div class="line">            <span class="keyword">if</span> (i):</div><div class="line">                lastlayer.append(i.val)</div><div class="line">        res.append(lastlayer)</div><div class="line">        </div><div class="line">        res.reverse()</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<p>参考链接：<a href="http://www.cnblogs.com/miloyip/archive/2010/05/12/binary_tree_traversal.html" target="_blank" rel="external">http://www.cnblogs.com/miloyip/archive/2010/05/12/binary_tree_traversal.html</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[102 Binary Tree Level Order Traversal]]></title>
      <url>http://wf94.github.io/2017/01/08/102-Binary-Tree-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br> Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  3</div><div class="line"> / \</div><div class="line">9  20</div><div class="line">  /  \</div><div class="line"> 15   7</div></pre></td></tr></table></figure>
<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [3],</div><div class="line">  [9,20],</div><div class="line">  [15,7]</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的层次优先遍历，需要涉及广度优先搜索(BFS)。将节点按层次出入队列可以轻松地输出连续的层次优先遍历结果。但是如果需要对每一层分别进行输出，就比较有技巧了。</p>
<p>比较常用的办法是使用空节点来充当层与层之间的分隔符，在python当中用<code>None</code>来表示。当队头访问到空节点后，队尾相应补充一个空节点，是为下一层的分隔符。需要注意的是，队列当中不能够添加额外的空节点，以防分层错乱；如果访问到树的底部，需要注意不要再添加空节点，以防陷入死循环。</p>
<p>python有自带的Queue（队列）类。在这里我利用list实现了一个简单的Queue，也可以实现同样的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        q = []</div><div class="line">        level = []</div><div class="line">        res = []</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            q.append(root)</div><div class="line">            q.append(<span class="keyword">None</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> q</div><div class="line">        <span class="keyword">while</span>(len(q) &gt; <span class="number">0</span>):</div><div class="line">            node = q[<span class="number">0</span>]</div><div class="line">            level.append(node)</div><div class="line">            <span class="keyword">del</span> q[<span class="number">0</span>]</div><div class="line">            <span class="keyword">if</span>(node):</div><div class="line">                <span class="keyword">if</span>(node.left):</div><div class="line">                    q.append(node.left)</div><div class="line">                <span class="keyword">if</span>(node.right):</div><div class="line">                    q.append(node.right)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                values = []</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> level:</div><div class="line">                    <span class="keyword">if</span> (i):</div><div class="line">                        values.append(i.val)</div><div class="line">                res.append(values)</div><div class="line">                level = []</div><div class="line">                <span class="keyword">if</span>(len(q) &gt; <span class="number">0</span>):</div><div class="line">                    q.append(<span class="keyword">None</span>)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[101 Symmetric Tree]]></title>
      <url>http://wf94.github.io/2017/01/07/101-Symmetric-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    1</div><div class="line">   / \</div><div class="line">  2   2</div><div class="line"> / \ / \</div><div class="line">3  4 4  3</div></pre></td></tr></table></figure>
<p>But the following <code>[1,2,2,null,3,null,3]</code>  is not:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  1</div><div class="line"> / \</div><div class="line">2   2</div><div class="line"> \   \</div><div class="line"> 3    3</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和其它的树相关的题目一样，这道题也可以考虑用DFS来进行搜索。在搜索的过程中，递归地判断左右子树是否符合对称条件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            <span class="keyword">return</span> self.Symmetric(root.left, root.right)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Symmetric</span><span class="params">(self, left, right)</span>:</span></div><div class="line">        <span class="keyword">if</span> (left <span class="keyword">and</span> right):</div><div class="line">            <span class="keyword">if</span> (left.val == right.val):</div><div class="line">                <span class="keyword">return</span> self.Symmetric(left.left, right.right) <span class="keyword">and</span> self.Symmetric(left.right, right.left)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">elif</span> (left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">None</span>):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[094 Binary Tree Inorder Traversal]]></title>
      <url>http://wf94.github.io/2017/01/07/094-Binary-Tree-Inorder-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p>
<p>For example:<br> Given binary tree <code>[1,null,2,3]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure>
<p>return <code>[1,3,2]</code>. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求我们中序遍历一棵树。依照题意，应当先访问左子树，之后访问根，最后访问右子树。</p>
<p>利用递归实现起来很容易，利用深度优先遍历(DFS)即可实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        res = []</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            self.DFS(root,res) </div><div class="line">        <span class="keyword">return</span> res</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self, root, res)</span>:</span></div><div class="line">        <span class="keyword">if</span> (root.left):</div><div class="line">            self.DFS(root.left, res)</div><div class="line">        res.append(root.val)</div><div class="line">        <span class="keyword">if</span> (root.right):</div><div class="line">            self.DFS(root.right, res)</div></pre></td></tr></table></figure>
<p>题目又提出了进一步的要求，需要我们使用迭代的方法来解决问题。</p>
<p>一般来说，深度优先的操作可以转换为栈的操作。我们发现不仅需要用栈，还需要利用一个能存访问过节点的数据结构才行，不然就会无限循环访问左子树，无法跳出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        stack = []</div><div class="line">        res = []</div><div class="line">        visit = &#123;&#125;</div><div class="line">        <span class="keyword">if</span> (root):</div><div class="line">            stack.append(root)</div><div class="line">            <span class="keyword">while</span>(len(stack)):</div><div class="line">                <span class="comment"># 在这里要注意加入visited选项，如果访问过该节点，就停止查找。</span></div><div class="line">                <span class="keyword">while</span> (stack[<span class="number">-1</span>].left <span class="keyword">and</span> <span class="keyword">not</span> visit.has_key(stack[<span class="number">-1</span>].left)):</div><div class="line">                    stack.append(stack[<span class="number">-1</span>].left)</div><div class="line">                cur = stack.pop()</div><div class="line">                res.append(cur.val)</div><div class="line">                visit[cur] = <span class="number">0</span></div><div class="line">                <span class="keyword">if</span> (cur.right):</div><div class="line">                    stack.append(cur.right)    </div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Medium </tag>
            
            <tag> Tree </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[088 Merge Sorted Array]]></title>
      <url>http://wf94.github.io/2017/01/06/088-Merge-Sorted-Array/</url>
      <content type="html"><![CDATA[<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong><br> You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>. The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这一题要搞清楚题意。利用题意给出的条件在原数组中进行操作即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums1: List[int]</div><div class="line">        :type m: int</div><div class="line">        :type nums2: List[int]</div><div class="line">        :type n: int</div><div class="line">        :rtype: void Do not return anything, modify nums1 in-place instead.</div><div class="line">        """</div><div class="line">        i = m - <span class="number">1</span></div><div class="line">        j = n - <span class="number">1</span></div><div class="line">        k = m + n - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>):</div><div class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums2[j]):</div><div class="line">                nums1[k] = nums1[i]</div><div class="line">                k -= <span class="number">1</span></div><div class="line">                i -= <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                nums1[k] = nums2[j]</div><div class="line">                k -= <span class="number">1</span></div><div class="line">                j -= <span class="number">1</span></div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>):</div><div class="line">            nums1[k] = nums2[j]</div><div class="line">            k -= <span class="number">1</span></div><div class="line">            j -= <span class="number">1</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[069 Sqrt(x)]]></title>
      <url>http://wf94.github.io/2017/01/06/069-Sqrt-x/</url>
      <content type="html"><![CDATA[<p>Implement <code>int sqrt(int x)</code>.</p>
<p>Compute and return the square root of <em>x</em>.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用二分法进行搜索，搜索到的结果进行平方，由此进行比对。</p>
<p>如果需要利用牛顿迭代法解决，最后得到的结果精度都比较高，一般来说是浮点类型的。在这题中，利用二分法可以达到预期的效果。利用牛顿迭代法反而会开销稍大。</p>
<p>在写二分法的时候，千万要注意边界条件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type x: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> x &lt;= <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> x</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            origin = x</div><div class="line">            high = x</div><div class="line">            low = <span class="number">0</span></div><div class="line">            prev = x</div><div class="line">            <span class="keyword">while</span> (prev != (high + low) / <span class="number">2</span>):</div><div class="line">                x = (high + low) / <span class="number">2</span></div><div class="line">                <span class="keyword">if</span> x * x &lt;= origin:</div><div class="line">                    low = x</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="comment"># 注意边界条件</span></div><div class="line">                    high = x + <span class="number">1</span></div><div class="line">                prev = x</div><div class="line">            <span class="keyword">return</span> low</div></pre></td></tr></table></figure>
<p>牛顿迭代法可以参考：<a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots" target="_blank" rel="external">https://en.wikipedia.org/wiki/Methods_of_computing_square_roots</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[067 Add Binary]]></title>
      <url>http://wf94.github.io/2017/01/05/067-Add-Binary/</url>
      <content type="html"><![CDATA[<p>Given two binary strings, return their sum (also a binary string). </p>
<p>For example,<br> a = <code>&quot;11&quot;</code><br> b = <code>&quot;1&quot;</code><br> Return <code>&quot;100&quot;</code>. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意考虑几个条件即可：a和b的长度不同，则位数短的字符串首先停止迭代；注意循环过程中和循环结束后的进位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type a: str</div><div class="line">        :type b: str</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        lena = len(a)</div><div class="line">        lenb = len(b)</div><div class="line"></div><div class="line">        count = summ = carry = <span class="number">0</span></div><div class="line">        result = <span class="string">''</span></div><div class="line">        <span class="keyword">while</span> (count &lt; lena <span class="keyword">or</span> count &lt; lenb):</div><div class="line">            <span class="keyword">if</span> (count &lt; lena <span class="keyword">and</span> count &lt; lenb):</div><div class="line">                summ = int(a[-count<span class="number">-1</span>]) + int(b[-count<span class="number">-1</span>]) + carry</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> (lena &gt; lenb):</div><div class="line">                    summ = int(a[-count<span class="number">-1</span>]) + carry</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    summ = int(b[-count<span class="number">-1</span>]) + carry</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (summ == <span class="number">2</span>):</div><div class="line">                carry = <span class="number">1</span></div><div class="line">                summ = <span class="number">0</span></div><div class="line">            <span class="keyword">elif</span> (summ == <span class="number">3</span>):</div><div class="line">                carry = <span class="number">1</span></div><div class="line">                summ = <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                carry = <span class="number">0</span></div><div class="line">                </div><div class="line">            result = str(summ) + result</div><div class="line">            count += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>):</div><div class="line">            result = str(carry) + result</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[058 Length of Last Word]]></title>
      <url>http://wf94.github.io/2017/01/05/058-Length-of-Last-Word/</url>
      <content type="html"><![CDATA[<p>Given a string <em>s</em> consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p><strong>Note:</strong> A word is defined as a character sequence consists of non-space characters only.</p>
<p>For example,<br> Given <em>s</em> = <code>&quot;Hello World&quot;</code>,<br> return <code>5</code>. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>想办法提取这个字符串所有的单词，然后就可以得到最后一个单词了。关键就是在于空格的处理与分割。需要注意多个空格、开头为空格的情况。</p>
<p>在这里利用了python内置的split方法，也是可行的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (len(s)):</div><div class="line">            l = s.split()</div><div class="line">            <span class="keyword">if</span> (len(l)):</div><div class="line">                <span class="keyword">return</span> len(l[len(l)<span class="number">-1</span>])</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p>P.S. 290题(Word Pattern)涉及到关于空格处理与分割的方法。</p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[053 Maximum Subarray]]></title>
      <url>http://wf94.github.io/2017/01/05/053-Maximum-Subarray/</url>
      <content type="html"><![CDATA[<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum. </p>
<p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br> the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>. </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题可以采用DP的方法来进行思考。遍历数组，访问每一个元素，计算当前元素之前的最大子数列(maximum subarray)的值。</p>
<p>利用两个变量来存储中间值，第一个变量final，存储的是当前的最大子数列(maximum subarray)的和，第二个变量sum，存储的是当前所有元素的非零和。</p>
<p>如果sum小于零，无论如何进行操作，后面的子数列(subarray)单独求和，要优于包含进之前元素的和。所以在计算sum的时候，如果和小于零，则置零。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        sum = <span class="number">0</span></div><div class="line">        final = float(<span class="string">"-inf"</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">            sum += i</div><div class="line">            final = max(sum, final)</div><div class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>):</div><div class="line">                sum = <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> final</div></pre></td></tr></table></figure>
<p>这也是一道经典的问题，该问题最初由布朗大学的Ulf Grenander教授于1977年提出，当初他为了展示数字图像中一个简单的最大然似然估计模型。不久之后卡内基梅隆大学的Jay Kadane提出了该问题的线性算法。上面所用的解法就类似于Kadane算法。</p>
<p>参考：<a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" target="_blank" rel="external">https://en.wikipedia.org/wiki/Maximum_subarray_problem</a></p>
<p>分治算法：<a href="http://xiadong.info/2016/08/leetcode-53-maximum-subarray/" target="_blank" rel="external">http://xiadong.info/2016/08/leetcode-53-maximum-subarray/</a></p>
<p><a href="https://discuss.leetcode.com/topic/426/how-to-solve-maximum-subarray-by-using-the-divide-and-conquer-approach/2" target="_blank" rel="external">https://discuss.leetcode.com/topic/426/how-to-solve-maximum-subarray-by-using-the-divide-and-conquer-approach/2</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Divide and Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[038 Count and Say]]></title>
      <url>http://wf94.github.io/2017/01/05/038-Count-and-Say/</url>
      <content type="html"><![CDATA[<p>The count-and-say sequence is the sequence of integers beginning as follows:<br><code>1, 11, 21, 1211, 111221, ...</code> </p>
<p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p>
<p>Given an integer <em>n</em>, generate the <em>n</em>th sequence. </p>
<p>Note: The sequence of integers will be represented as a string. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>以1为种子，生成一个符合题意的结果即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        string = <span class="string">'1'</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</div><div class="line">            length = len(string)</div><div class="line">            count = <span class="number">1</span></div><div class="line">            temp = <span class="string">''</span></div><div class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> range(length):</div><div class="line">                <span class="keyword">if</span> (m == length<span class="number">-1</span>):</div><div class="line">                    temp += str(count)</div><div class="line">                    temp += string[m]</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">if</span> (string[m] == string[m+<span class="number">1</span>]):</div><div class="line">                        count += <span class="number">1</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        temp += str(count)</div><div class="line">                        temp += string[m]</div><div class="line">                        count = <span class="number">1</span></div><div class="line">            string = temp</div><div class="line">        <span class="keyword">return</span> string</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[036 Valid Sukodu]]></title>
      <url>http://wf94.github.io/2017/01/04/036-Valid-Sudoku/</url>
      <content type="html"><![CDATA[<p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx" target="_blank" rel="external">Sudoku Puzzles - The Rules</a>.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>&#39;.&#39;</code>.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>需要熟悉数独的规则，利用哈希表来进行判断。</p>
<p>数独的棋盘大小是一定的，不需要考虑时间的耗费，直接利用穷举法把所有情况列举出来，判断数独是否有效。</p>
<p>判断条件是：每一行、每一列、每一个3×3子块，不能有重复的数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type board: List[List[str]]</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        collen = len(board)</div><div class="line">        rowlen = len(board[<span class="number">0</span>])</div><div class="line">        </div><div class="line">        squarelen = <span class="number">3</span></div><div class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> board:</div><div class="line">            linedict = &#123;&#125;</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> line:</div><div class="line">                <span class="keyword">if</span> (i != <span class="string">'.'</span>):</div><div class="line">                    <span class="keyword">if</span> (linedict.has_key(i)):</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        linedict[i] = <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rowlen):</div><div class="line">            rowdict = &#123;&#125;</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(collen):</div><div class="line">                <span class="keyword">if</span> (board[j][i] != <span class="string">'.'</span>):</div><div class="line">                    <span class="keyword">if</span> (rowdict.has_key(board[j][i])):</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        rowdict[board[j][i]] = <span class="number">1</span></div><div class="line">                        </div><div class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>]:</div><div class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>]:</div><div class="line">                squaredict = &#123;&#125;</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(squarelen):</div><div class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(squarelen):</div><div class="line">                        cur = board[i+m][j+n]</div><div class="line">                        <span class="keyword">if</span> (cur != <span class="string">'.'</span>):</div><div class="line">                            <span class="keyword">if</span> (squaredict.has_key(cur)):</div><div class="line">                                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                            <span class="keyword">else</span>:</div><div class="line">                                squaredict[cur] = <span class="number">1</span></div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Medium </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[035 Search Insert Position]]></title>
      <url>http://wf94.github.io/2017/01/04/035-Search-Insert-Position/</url>
      <content type="html"><![CDATA[<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p>Here are few examples.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[1,3,5,6], 5 → 2</div><div class="line">[1,3,5,6], 2 → 1</div><div class="line">[1,3,5,6], 7 → 4</div><div class="line">[1,3,5,6], 0 → 0</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题我就利用O(n)的时间复杂度，鉴于题目难度，时间上还是可以接受的。<br>如果需要优化，可以用二分查找法，在利用二分查找法的时候注意边界条件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type target: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        ans = <span class="number">0</span></div><div class="line">        length = len(nums)</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> target &gt; nums[i]:</div><div class="line">                ans = i + <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> target == nums[i]:</div><div class="line">                ans = i</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">return</span> ans</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[028 Implement strStr]]></title>
      <url>http://wf94.github.io/2017/01/04/028-Implement-strStr/</url>
      <content type="html"><![CDATA[<p>Implement strStr(). </p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出haystack字符串中，needle字符串第一次出现的索引号。</p>
<p>利用两层循环可以得到想要的结果，因为题目难度所限，对于O(n*m)的时间复杂度也没有报超时错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type haystack: str</div><div class="line">        :type needle: str</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        length = len(haystack)</div><div class="line">        lenned = len(needle)</div><div class="line">        <span class="keyword">if</span> (length == lenned <span class="keyword">and</span> length == <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">            </div><div class="line">        <span class="keyword">if</span> (length &lt; lenned):</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">            </div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">                flag = <span class="number">1</span></div><div class="line">                pos = i</div><div class="line">                <span class="comment"># 超出范围，needle不在haystack里</span></div><div class="line">                <span class="keyword">if</span> (pos + lenned &gt; length):</div><div class="line">                    flag = <span class="number">0</span></div><div class="line">                    <span class="keyword">break</span></div><div class="line">                <span class="comment"># 判断needle是不是真的在haystack里</span></div><div class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> needle:</div><div class="line">                    <span class="keyword">if</span> (haystack[pos] != j):</div><div class="line">                        flag = <span class="number">0</span></div><div class="line">                        <span class="keyword">break</span></div><div class="line">                    pos += <span class="number">1</span></div><div class="line">                <span class="comment"># 返回对应的字符串索引</span></div><div class="line">                <span class="keyword">if</span> (flag):</div><div class="line">                    <span class="keyword">return</span> i</div><div class="line">                    </div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[024 Swap Nodes in Pairs]]></title>
      <url>http://wf94.github.io/2017/01/04/024-Swap-Nodes-in-Pairs/</url>
      <content type="html"><![CDATA[<p>Given a linked list, swap every two adjacent nodes and return its head. </p>
<p>For example,<br> Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>. </p>
<p>Your algorithm should use only constant space. You may <strong>not</strong> modify the values in the list, only nodes itself can be changed. </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一个单链表的题目，需要对连续两个节点进行操作。需要注意的是，不能改变链表的数值，只能修改结构。</p>
<p>将连接相邻节点的next指针重置即可得到结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</div><div class="line"></div><div class="line">  1 X 2 X 3-&gt;4-&gt;5-&gt;6</div><div class="line"></div><div class="line">  1&lt;-2 X 3-&gt;4-&gt;5-&gt;6</div><div class="line"></div><div class="line"> -&gt;2-&gt;1-&gt;4.....</div></pre></td></tr></table></figure>
<p>将2指向1，1指向4，即完成一次转换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: ListNode</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (head <span class="keyword">and</span> head.next):</div><div class="line">            cur1 = head</div><div class="line">            cur2 = <span class="keyword">None</span></div><div class="line">            cur3 = <span class="keyword">None</span></div><div class="line">            <span class="comment"># 用来指示是否是第一次操作，如果是，</span></div><div class="line">            <span class="comment"># 还需要更改头节点的指向，让头节点指向第二个节点</span></div><div class="line">            firsttime = <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> (cur1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</div><div class="line">                cur2 = cur1.next</div><div class="line">                <span class="keyword">if</span> (cur2):</div><div class="line">                    cur3 = cur2.next</div><div class="line">                    <span class="keyword">if</span> (cur2.next <span class="keyword">and</span> cur2.next.next):</div><div class="line">                        cur1.next = cur2.next.next</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        cur1.next = cur2.next</div><div class="line">                    cur2.next = cur1</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    cur3 = <span class="keyword">None</span></div><div class="line">                <span class="keyword">if</span> (firsttime):</div><div class="line">                    head = cur2</div><div class="line">                cur1 = cur3</div><div class="line">                firsttime = <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> head</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[020 Valid Parentheses]]></title>
      <url>http://wf94.github.io/2017/01/03/020-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<p>Given a string containing just the characters (), [], {}, determine if the input string is valid.</p>
<p>The brackets must close in the correct order.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在考虑这样的题目的时候，边界条件一定要判断清楚。首先，不是说任意一对括号相配对就可以了，还需要考虑括号的种类；其次，括号的配对不能错位嵌套。</p>
<p>本题利用堆栈可以很容易解决。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        p = []</div><div class="line">        flag = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> (i == <span class="string">'('</span> <span class="keyword">or</span> i == <span class="string">'['</span> <span class="keyword">or</span> i == <span class="string">'&#123;'</span>):</div><div class="line">                p.append(i)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> (len(p)):       </div><div class="line">                    j = p.pop()</div><div class="line">                    <span class="comment"># ord函数可以获得该符号的ASCII码</span></div><div class="line">                    <span class="keyword">if</span> (ord(i) - ord(j) == <span class="number">1</span> <span class="keyword">or</span> ord(i) - ord(j) == <span class="number">2</span>):</div><div class="line">                        flag = <span class="number">1</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        flag = <span class="number">0</span></div><div class="line">                        <span class="keyword">break</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    flag = <span class="number">0</span></div><div class="line">                    <span class="keyword">break</span></div><div class="line">        <span class="keyword">if</span> (flag <span class="keyword">and</span> len(p) == <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[019 Remove Nth Node From End of List]]></title>
      <url>http://wf94.github.io/2017/01/03/019-Remove-Nth-Node-From-End-of-List/</url>
      <content type="html"><![CDATA[<p>Given a linked list, remove the <em>n</em>th node from the end of list and return its head. Given <em>n</em> will always be valid and try to do this in one pass. </p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</div><div class="line"></div><div class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道非常典型的快慢指针题。双指针的操作在链表中比较常用，这样的操作可以省去频繁对链表进行遍历的开销，非常方便。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head: ListNode</div><div class="line">        :type n: int</div><div class="line">        :rtype: ListNode</div><div class="line">        """</div><div class="line">        fast = head</div><div class="line">        headflag = <span class="number">1</span></div><div class="line">        <span class="comment"># 利用快指针来定位倒数第n个元素</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            fast = fast.next</div><div class="line">        <span class="comment"># 慢指针必须要指到目标元素前一个元素</span></div><div class="line">        <span class="comment"># 才能执行单链表的删除操作</span></div><div class="line">        <span class="keyword">if</span> (fast):</div><div class="line">            fast = fast.next</div><div class="line">            headflag = <span class="number">0</span></div><div class="line">        slow = head</div><div class="line">        <span class="keyword">while</span>(fast):</div><div class="line">            fast = fast.next</div><div class="line">            slow = slow.next</div><div class="line">        <span class="comment"># 经过循环，现在慢指针已经指向目标元素的前一个元素了</span></div><div class="line">        <span class="keyword">if</span> (slow == head):</div><div class="line">            <span class="comment"># 边界条件：如果慢指针还在头部</span></div><div class="line">            <span class="keyword">if</span> (headflag):</div><div class="line">                <span class="comment"># 删除第一个元素</span></div><div class="line">                head = slow.next</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                slow.next = slow.next.next</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            slow.next = slow.next.next</div><div class="line">        <span class="keyword">return</span> head</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[014 Longest Common Prefix]]></title>
      <url>http://wf94.github.io/2017/01/02/014-Longest-Common-Prefix/</url>
      <content type="html"><![CDATA[<p>Write a function to find the longest common prefix string amongst an array of strings. </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意，参数strs是一个string类型的数组。思路很直白，从数组中每一个字符串的起始位置开始搜索并依次进行比较。只要有其中一个字符串在该位置的字符与其它的字符串不同，搜索结束，从而得到字符串数组的最长公共前缀。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type strs: List[str]</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        length = len(strs)</div><div class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="string">''</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            pos = <span class="number">0</span></div><div class="line">            res = <span class="string">''</span></div><div class="line">            <span class="keyword">while</span>(<span class="keyword">True</span>):</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">                    <span class="keyword">if</span> (pos &gt;= len(strs[i])):</div><div class="line">                        <span class="keyword">return</span> res</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        <span class="keyword">if</span> (strs[i][pos] != strs[<span class="number">0</span>][pos]):</div><div class="line">                            <span class="keyword">return</span> res</div><div class="line">                res += strs[<span class="number">0</span>][pos]</div><div class="line">                pos += <span class="number">1</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[009 Palindrome Number]]></title>
      <url>http://wf94.github.io/2017/01/02/009-Palindrome-Number/</url>
      <content type="html"><![CDATA[<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题如果想用类似于第八题的方法，把每一位的数字都存在一个数组里，显然空间开销会比较大，从而与题意不符。因此，在循环当中，利用数学方法将各位对应数字计算出来，直接进行比较，会显得比较简洁。</p>
<p>需要注意的是，负数不是回文数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type x: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> ( x &gt;= <span class="number">0</span> ):</div><div class="line">            digit = <span class="number">0</span></div><div class="line">            i = x  </div><div class="line">            <span class="keyword">while</span>( i &gt; <span class="number">0</span> ):</div><div class="line">                i = i / <span class="number">10</span></div><div class="line">                digit += <span class="number">1</span></div><div class="line">            high = digit</div><div class="line">            low = <span class="number">1</span></div><div class="line">            m = x</div><div class="line">            n = x</div><div class="line">            <span class="keyword">while</span> (high &gt;= low):</div><div class="line">                <span class="keyword">if</span> (m / (<span class="number">10</span> ** (high<span class="number">-1</span>)) != n % <span class="number">10</span>):</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                m = m - ( (<span class="number">10</span> ** (high<span class="number">-1</span>)) * (m / (<span class="number">10</span> ** (high<span class="number">-1</span>))))</div><div class="line">                n = n / <span class="number">10</span></div><div class="line">                high -= <span class="number">1</span></div><div class="line">                low += <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[008 String to Integer (atoi)]]></title>
      <url>http://wf94.github.io/2017/01/02/008-String-to-Integer-atoi/</url>
      <content type="html"><![CDATA[<p>Implement atoi to convert a string to an integer.</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>atoi函数的主要功能就是将字符串转换成整数，题目给出了提示，需要我们考虑清楚所有可能的情况。</p>
<p>百密必有一疏，在我写完代码第一次运行的时候，还是漏掉了以下三项：</p>
<ol>
<li>应当去掉尽可能多的空格；</li>
<li>字符串起始可以含有+号，并将此数视为正数；</li>
<li>在数字之后应当可以包含任何字符。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type str: str</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        </div><div class="line">        symbols = [<span class="string">"+"</span>,<span class="string">"-"</span>]</div><div class="line">        numbers = [<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>]</div><div class="line">        length = len(str)</div><div class="line">        symbol = <span class="string">"+"</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        </div><div class="line">        res = []</div><div class="line">        cur = <span class="number">0</span></div><div class="line">        <span class="comment"># 去除一开始的空格</span></div><div class="line">        <span class="keyword">while</span> (str[cur] == <span class="string">" "</span>):</div><div class="line">            cur += <span class="number">1</span></div><div class="line">        <span class="comment"># 判断第一个字符是不是所期待的字符</span></div><div class="line">        <span class="keyword">if</span> ( (str[cur] <span class="keyword">not</span> <span class="keyword">in</span> symbols) <span class="keyword">and</span> (str[cur] <span class="keyword">not</span> <span class="keyword">in</span> numbers) ):</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># 是符号的话，就存起来；否则开始转换成数字</span></div><div class="line">            <span class="keyword">if</span> (str[cur] <span class="keyword">in</span> symbols):</div><div class="line">                symbol = str[cur]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                res.append(str[cur])</div><div class="line">            cur += <span class="number">1</span></div><div class="line">            </div><div class="line">            <span class="comment"># 注意到数字之后还能有别的乱七八糟的符号</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(cur, length):</div><div class="line">                <span class="keyword">if</span> (str[i] <span class="keyword">not</span> <span class="keyword">in</span> numbers):</div><div class="line">                    <span class="keyword">break</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    res.append(str[i])</div><div class="line">        </div><div class="line">        <span class="comment"># 处理转换数字的操作</span></div><div class="line">        reslen = len(res)</div><div class="line">        <span class="keyword">if</span> (reslen &lt;= <span class="number">0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            answer = <span class="number">0</span></div><div class="line">            count = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> res[::<span class="number">-1</span>]:</div><div class="line">                answer += <span class="number">10</span> ** count * int(i)</div><div class="line">                count += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> (symbol == <span class="string">"-"</span>):</div><div class="line">                answer = -answer</div><div class="line">            <span class="comment"># 注意数字不能越界，python的整数范围比int的值要大</span></div><div class="line">            <span class="keyword">if</span> (answer &gt; <span class="number">2147483647</span>):</div><div class="line">                answer = <span class="number">2147483647</span></div><div class="line">            <span class="keyword">elif</span> (answer &lt; <span class="number">-2147483648</span>):</div><div class="line">                answer = <span class="number">-2147483648</span></div><div class="line">            <span class="keyword">return</span> answer</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[007 Reverse Integer]]></title>
      <url>http://wf94.github.io/2017/01/02/007-Reverse-Integer/</url>
      <content type="html"><![CDATA[<p>Reverse digits of an integer.</p>
<p><strong>Example1:</strong>  x =  123,   return  321<br><strong>Example2:</strong>  x = -123,   return -321 </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一次失败的尝试。考虑的情况太多，以至于没有好好地去整合。</p>
<p>必须注意的是，我们需要考虑如果翻转 100 这个数，最后的结果是怎么样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type x: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> (x != <span class="number">0</span>):</div><div class="line">            <span class="comment"># 首先不应该加一个判断是否为0的分支，没有意义啊。0也是无所谓符号的嘛</span></div><div class="line">            isNegative = <span class="keyword">False</span></div><div class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>):</div><div class="line">                x = -x</div><div class="line">                isNegative = <span class="keyword">True</span></div><div class="line">            <span class="comment"># 获得每一位的数字具体是多少，放到res里面</span></div><div class="line">            res = []</div><div class="line">            <span class="keyword">while</span> (x &gt; <span class="number">0</span>):</div><div class="line">                res.append(x % <span class="number">10</span>)</div><div class="line">                x = x / <span class="number">10</span></div><div class="line">            <span class="keyword">while</span> (res[<span class="number">0</span>] == <span class="number">0</span>):</div><div class="line">                <span class="keyword">del</span> res[<span class="number">0</span>]</div><div class="line"></div><div class="line">            <span class="comment"># 反向遍历res，结果赋值给ans</span></div><div class="line">            length = len(res)</div><div class="line">            <span class="keyword">if</span> (length):</div><div class="line">                ans = <span class="number">0</span></div><div class="line">                <span class="comment">#可以写成 for i, enum in enumerate(res[::-1])</span></div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">                    ans += res[-(i+<span class="number">1</span>)] * ( <span class="number">10</span> ** i )</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (isNegative):</div><div class="line">                ans = -ans</div><div class="line"></div><div class="line">            <span class="comment">#可以利用python自带的MAXINT/MININT参数</span></div><div class="line">            <span class="keyword">if</span> (ans &lt; <span class="number">-2</span> ** <span class="number">31</span> <span class="keyword">or</span> ans &gt; <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>):</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> ans</div><div class="line"></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p>最后，可以参考一下示例代码，不需要这么多判断分支，也能完成这道题。<br><a href="https://discuss.leetcode.com/topic/6005/shortest-code-possible-in-c" target="_blank" rel="external">https://discuss.leetcode.com/topic/6005/shortest-code-possible-in-c</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int reverse(int x) &#123;</div><div class="line">        long long res = 0;</div><div class="line">        while(x) &#123;</div><div class="line">            res = res*10 + x%10;</div><div class="line">            x /= 10;</div><div class="line">        &#125;</div><div class="line">        return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[006 Zigzag Conversion]]></title>
      <url>http://wf94.github.io/2017/01/01/006-Zigzag-Conversion/</url>
      <content type="html"><![CDATA[<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">P   A   H   N</div><div class="line">A P L S I I G</div><div class="line">Y   I   R</div></pre></td></tr></table></figure>
<p>And then read line by line: “PAHNAPLSIIGYIR”</p>
<p>Write the code that will take a string and make this conversion given a number of rows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">convert(&quot;PAYPALISHIRING&quot;, 3) ==&gt;  &quot;PAHNAPLSIIGYIR&quot;</div></pre></td></tr></table></figure></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先考虑最简单的情况，行数为2的时候，行数为3的时候每一个元素的分布情况。可以发现，元素分布是有规律的。就拿例子而言，第一行的元素之间相隔3个字符，第二行的元素之间相隔1个字符，利用求余操作就可以得到对应关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s, numRows)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :type numRows: int</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        strlist = []</div><div class="line">        length = len(s)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows):</div><div class="line">            strlist.append(<span class="string">""</span>)</div><div class="line">            </div><div class="line">        <span class="keyword">if</span> (numRows != <span class="number">1</span>):</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">                remain = i % (<span class="number">2</span> * (numRows<span class="number">-1</span>) )</div><div class="line">                <span class="keyword">if</span> (remain &gt;= numRows):</div><div class="line">                    remain = (<span class="number">2</span> * (numRows<span class="number">-1</span>) ) - remain</div><div class="line">                strlist[remain] += s[i]</div><div class="line">                </div><div class="line">            res = <span class="string">""</span></div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> strlist:</div><div class="line">                res += k</div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        </div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> s</div></pre></td></tr></table></figure>
<p>下图也可以更好地理解此题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Δ=2n-2    1                           2n-1                         4n-3</div><div class="line">Δ=        2                     2n-2  2n                    4n-4   4n-2</div><div class="line">Δ=        3               2n-3        2n+1              4n-5       .</div><div class="line">Δ=        .           .               .               .            .</div><div class="line">Δ=        .       n+2                 .           3n               .</div><div class="line">Δ=        n-1 n+1                     3n-3    3n-1                 5n-5</div><div class="line">Δ=2n-2    n                           3n-2                         5n-4</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[001 Two Sum]]></title>
      <url>http://wf94.github.io/2017/01/01/001-Two-Sum/</url>
      <content type="html"><![CDATA[<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Given nums = [2, 7, 11, 15], target = 9,</div><div class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line">return [0, 1].</div></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为题目给出的数组当中一定会有且只有一个解，而且不能重复用一个元素。所以第一层循环用以遍历数组中的元素，第二层循环用以查询此元素之后，是否还有元素满足要求。</p>
<p>因为这一题的难度是easy，所以利用上面所说，类似于穷举的方法就可以直接得到结果，不需要考虑额外的时间复杂度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type target: int</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            remain = target - nums[i]</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, length):</div><div class="line">                <span class="keyword">if</span> (nums[j] == remain):</div><div class="line">                    <span class="keyword">return</span> [i, j]</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Array </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
